---
layout: chapter
title: The Phylogenetic Model
output:
  html_document:
    toc: true
    toc_float: true
pdf: true
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The Phylogenetic Model</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">The Phylogenetic Model</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter-6-computing-the-likelihood">Chapter 6: Computing the Likelihood</a><ul>
<li><a href="#section-6.1-felsensteins-pruning-algorithm">Section 6.1: Felsenstein’s pruning algorithm</a></li>
<li><a href="#section-6.xxx-exercises">Section 6.xxx: Exercises</a><ul>
<li><a href="#section-6.xxx.1-compute-the-likelihood-under-the-f81-substitution-model">Section 6.xxx.1: Compute the likelihood under the F81 substitution model</a></li>
<li><a href="#section-6.xxx.2-add-among-site-rate-variation-using-a-discretize-gamma-distribution">Section 6.xxx.2: Add among site rate variation using a discretize Gamma distribution</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<div>
<p><a href="{{site.baseurl}}/pdf/chapter6.pdf">pdf version</a></p>
</div>
<h1 id="chapter-6-computing-the-likelihood">Chapter 6: Computing the Likelihood</h1>
<h2 id="section-6.1-felsensteins-pruning-algorithm">Section 6.1: Felsenstein’s pruning algorithm</h2>
<p>In our previous chapters, especially in Chapter 2 when we implemented the <strong>Alignment</strong> class, we left out one method that we need today. The specific method that we need is one that compute the initial likelihoods for a given nucleotide character. For example, the nucleotide ‘A’ should give a vector of <strong>[1,0,0,0]</strong> whereas the nucleotide ‘T’ should return <strong>[0,0,0,1]</strong>. Furthermore, we code ambiguous states, such as ‘?’, by saying that if this nucleotide were actually a ‘C’, then with probability one we would have called it a ‘?’. Thus, a ‘?’ returns <strong>[1,1,1,1]</strong> but a ‘R’ which stands for a purine, coding an ‘A’ or ‘G’, returns a <strong>[1,0,1,0]</strong>.</p>
<p>Add this method the the <strong>Alignment.h</strong> file.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;                    getNucleotideStates(<span class="dt">char</span> nuc) <span class="at">const</span>;</span></code></pre></div>
<p>Also, add the implementation to the file <strong>Alignment.cpp</strong>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">/**</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co"> *</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"> *  Get the states for a nucleotide represented as a character</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co"> *</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"> *   This function initializes a vector, nuc[MAX_NUM_STATES]. The four elements</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co"> *   of nuc correspond to the four nucleotides in alphabetical order.</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co"> *   We are assuming that the nucCode is a binary representation of</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co"> *   the nucleotides that are consistent with the observation. For</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co"> *   example, if we observe an A, then the nucCode is 1 and the</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co"> *   function initalizes nuc[0] = 1 and the other elements of nuc</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co"> *   to be 0.</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co"> *</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="co"> *   Observation    nucCode        nuc</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co"> *        A            1           1000</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="co"> *        C            2           0100</span></span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="co"> *        G            4           0010</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="co"> *        T            8           0001</span></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="co"> *        R            5           1010</span></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="co"> *        Y           10           0101</span></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="co"> *        M            3           1100</span></span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="co"> *        K           12           0011</span></span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="co"> *        S            6           0110</span></span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="co"> *        W            9           1001</span></span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="co"> *        H           11           1101</span></span>
<span id="cb2-25"><a href="#cb2-25"></a><span class="co"> *        B           14           0111</span></span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="co"> *        V            7           1110</span></span>
<span id="cb2-27"><a href="#cb2-27"></a><span class="co"> *        D           13           1011</span></span>
<span id="cb2-28"><a href="#cb2-28"></a><span class="co"> *        N - ?       15           1111</span></span>
<span id="cb2-29"><a href="#cb2-29"></a><span class="co"> *</span></span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="co"> */</span></span>
<span id="cb2-31"><a href="#cb2-31"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; Alignment::getNucleotideStates (<span class="dt">char</span> nuc) <span class="at">const</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>{</span>
<span id="cb2-33"><a href="#cb2-33"></a></span>
<span id="cb2-34"><a href="#cb2-34"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; states(<span class="dv">4</span>,<span class="dv">0</span>);</span>
<span id="cb2-35"><a href="#cb2-35"></a></span>
<span id="cb2-36"><a href="#cb2-36"></a>    <span class="cf">switch</span> ( nuc )</span>
<span id="cb2-37"><a href="#cb2-37"></a>    {</span>
<span id="cb2-38"><a href="#cb2-38"></a>        <span class="cf">case</span> <span class="ch">&#39;A&#39;</span>:</span>
<span id="cb2-39"><a href="#cb2-39"></a>            states[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-40"><a href="#cb2-40"></a>            states[<span class="dv">1</span>] = <span class="dv">0</span>;</span>
<span id="cb2-41"><a href="#cb2-41"></a>            states[<span class="dv">2</span>] = <span class="dv">0</span>;</span>
<span id="cb2-42"><a href="#cb2-42"></a>            states[<span class="dv">3</span>] = <span class="dv">0</span>;</span>
<span id="cb2-43"><a href="#cb2-43"></a>            <span class="cf">break</span>;</span>
<span id="cb2-44"><a href="#cb2-44"></a>        <span class="cf">case</span> <span class="ch">&#39;C&#39;</span>:</span>
<span id="cb2-45"><a href="#cb2-45"></a>            states[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb2-46"><a href="#cb2-46"></a>            states[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb2-47"><a href="#cb2-47"></a>            states[<span class="dv">2</span>] = <span class="dv">0</span>;</span>
<span id="cb2-48"><a href="#cb2-48"></a>            states[<span class="dv">3</span>] = <span class="dv">0</span>;</span>
<span id="cb2-49"><a href="#cb2-49"></a>            <span class="cf">break</span>;</span>
<span id="cb2-50"><a href="#cb2-50"></a>        <span class="cf">case</span> <span class="ch">&#39;M&#39;</span>:</span>
<span id="cb2-51"><a href="#cb2-51"></a>            states[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-52"><a href="#cb2-52"></a>            states[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb2-53"><a href="#cb2-53"></a>            states[<span class="dv">2</span>] = <span class="dv">0</span>;</span>
<span id="cb2-54"><a href="#cb2-54"></a>            states[<span class="dv">3</span>] = <span class="dv">0</span>;</span>
<span id="cb2-55"><a href="#cb2-55"></a>            <span class="cf">break</span>;</span>
<span id="cb2-56"><a href="#cb2-56"></a>        <span class="cf">case</span> <span class="ch">&#39;G&#39;</span>:</span>
<span id="cb2-57"><a href="#cb2-57"></a>            states[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb2-58"><a href="#cb2-58"></a>            states[<span class="dv">1</span>] = <span class="dv">0</span>;</span>
<span id="cb2-59"><a href="#cb2-59"></a>            states[<span class="dv">2</span>] = <span class="dv">1</span>;</span>
<span id="cb2-60"><a href="#cb2-60"></a>            states[<span class="dv">3</span>] = <span class="dv">0</span>;</span>
<span id="cb2-61"><a href="#cb2-61"></a>            <span class="cf">break</span>;</span>
<span id="cb2-62"><a href="#cb2-62"></a>        <span class="cf">case</span> <span class="ch">&#39;R&#39;</span>:</span>
<span id="cb2-63"><a href="#cb2-63"></a>            states[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-64"><a href="#cb2-64"></a>            states[<span class="dv">1</span>] = <span class="dv">0</span>;</span>
<span id="cb2-65"><a href="#cb2-65"></a>            states[<span class="dv">2</span>] = <span class="dv">1</span>;</span>
<span id="cb2-66"><a href="#cb2-66"></a>            states[<span class="dv">3</span>] = <span class="dv">0</span>;</span>
<span id="cb2-67"><a href="#cb2-67"></a>            <span class="cf">break</span>;</span>
<span id="cb2-68"><a href="#cb2-68"></a>        <span class="cf">case</span> <span class="ch">&#39;S&#39;</span>:</span>
<span id="cb2-69"><a href="#cb2-69"></a>            states[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb2-70"><a href="#cb2-70"></a>            states[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb2-71"><a href="#cb2-71"></a>            states[<span class="dv">2</span>] = <span class="dv">1</span>;</span>
<span id="cb2-72"><a href="#cb2-72"></a>            states[<span class="dv">3</span>] = <span class="dv">0</span>;</span>
<span id="cb2-73"><a href="#cb2-73"></a>            <span class="cf">break</span>;</span>
<span id="cb2-74"><a href="#cb2-74"></a>        <span class="cf">case</span> <span class="ch">&#39;V&#39;</span>:</span>
<span id="cb2-75"><a href="#cb2-75"></a>            states[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-76"><a href="#cb2-76"></a>            states[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb2-77"><a href="#cb2-77"></a>            states[<span class="dv">2</span>] = <span class="dv">1</span>;</span>
<span id="cb2-78"><a href="#cb2-78"></a>            states[<span class="dv">3</span>] = <span class="dv">0</span>;</span>
<span id="cb2-79"><a href="#cb2-79"></a>            <span class="cf">break</span>;</span>
<span id="cb2-80"><a href="#cb2-80"></a>        <span class="cf">case</span> <span class="ch">&#39;T&#39;</span>:</span>
<span id="cb2-81"><a href="#cb2-81"></a>            states[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb2-82"><a href="#cb2-82"></a>            states[<span class="dv">1</span>] = <span class="dv">0</span>;</span>
<span id="cb2-83"><a href="#cb2-83"></a>            states[<span class="dv">2</span>] = <span class="dv">0</span>;</span>
<span id="cb2-84"><a href="#cb2-84"></a>            states[<span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb2-85"><a href="#cb2-85"></a>            <span class="cf">break</span>;</span>
<span id="cb2-86"><a href="#cb2-86"></a>        <span class="cf">case</span> <span class="ch">&#39;W&#39;</span>:</span>
<span id="cb2-87"><a href="#cb2-87"></a>            states[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-88"><a href="#cb2-88"></a>            states[<span class="dv">1</span>] = <span class="dv">0</span>;</span>
<span id="cb2-89"><a href="#cb2-89"></a>            states[<span class="dv">2</span>] = <span class="dv">0</span>;</span>
<span id="cb2-90"><a href="#cb2-90"></a>            states[<span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb2-91"><a href="#cb2-91"></a>            <span class="cf">break</span>;</span>
<span id="cb2-92"><a href="#cb2-92"></a>        <span class="cf">case</span> <span class="ch">&#39;Y&#39;</span>:</span>
<span id="cb2-93"><a href="#cb2-93"></a>            states[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb2-94"><a href="#cb2-94"></a>            states[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb2-95"><a href="#cb2-95"></a>            states[<span class="dv">2</span>] = <span class="dv">0</span>;</span>
<span id="cb2-96"><a href="#cb2-96"></a>            states[<span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb2-97"><a href="#cb2-97"></a>            <span class="cf">break</span>;</span>
<span id="cb2-98"><a href="#cb2-98"></a>        <span class="cf">case</span> <span class="ch">&#39;H&#39;</span>:</span>
<span id="cb2-99"><a href="#cb2-99"></a>            states[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-100"><a href="#cb2-100"></a>            states[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb2-101"><a href="#cb2-101"></a>            states[<span class="dv">2</span>] = <span class="dv">0</span>;</span>
<span id="cb2-102"><a href="#cb2-102"></a>            states[<span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb2-103"><a href="#cb2-103"></a>            <span class="cf">break</span>;</span>
<span id="cb2-104"><a href="#cb2-104"></a>        <span class="cf">case</span> <span class="ch">&#39;K&#39;</span>:</span>
<span id="cb2-105"><a href="#cb2-105"></a>            states[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb2-106"><a href="#cb2-106"></a>            states[<span class="dv">1</span>] = <span class="dv">0</span>;</span>
<span id="cb2-107"><a href="#cb2-107"></a>            states[<span class="dv">2</span>] = <span class="dv">1</span>;</span>
<span id="cb2-108"><a href="#cb2-108"></a>            states[<span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb2-109"><a href="#cb2-109"></a>            <span class="cf">break</span>;</span>
<span id="cb2-110"><a href="#cb2-110"></a>        <span class="cf">case</span> <span class="ch">&#39;D&#39;</span>:</span>
<span id="cb2-111"><a href="#cb2-111"></a>            states[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-112"><a href="#cb2-112"></a>            states[<span class="dv">1</span>] = <span class="dv">0</span>;</span>
<span id="cb2-113"><a href="#cb2-113"></a>            states[<span class="dv">2</span>] = <span class="dv">1</span>;</span>
<span id="cb2-114"><a href="#cb2-114"></a>            states[<span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb2-115"><a href="#cb2-115"></a>            <span class="cf">break</span>;</span>
<span id="cb2-116"><a href="#cb2-116"></a>        <span class="cf">case</span> <span class="ch">&#39;B&#39;</span>:</span>
<span id="cb2-117"><a href="#cb2-117"></a>            states[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb2-118"><a href="#cb2-118"></a>            states[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb2-119"><a href="#cb2-119"></a>            states[<span class="dv">2</span>] = <span class="dv">1</span>;</span>
<span id="cb2-120"><a href="#cb2-120"></a>            states[<span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb2-121"><a href="#cb2-121"></a>            <span class="cf">break</span>;</span>
<span id="cb2-122"><a href="#cb2-122"></a>        <span class="cf">case</span> <span class="ch">&#39;?&#39;</span>:</span>
<span id="cb2-123"><a href="#cb2-123"></a>        <span class="cf">case</span> <span class="ch">&#39;-&#39;</span>:</span>
<span id="cb2-124"><a href="#cb2-124"></a>        <span class="cf">case</span> <span class="ch">&#39;N&#39;</span>:</span>
<span id="cb2-125"><a href="#cb2-125"></a>            states[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-126"><a href="#cb2-126"></a>            states[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb2-127"><a href="#cb2-127"></a>            states[<span class="dv">2</span>] = <span class="dv">1</span>;</span>
<span id="cb2-128"><a href="#cb2-128"></a>            states[<span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb2-129"><a href="#cb2-129"></a>    }</span>
<span id="cb2-130"><a href="#cb2-130"></a></span>
<span id="cb2-131"><a href="#cb2-131"></a>    <span class="cf">return</span> states;</span>
<span id="cb2-132"><a href="#cb2-132"></a> }</span></code></pre></div>
<p>This was a lot of basic copy and paste. Now we can go back to our <strong>PhyloCTMC</strong> class.</p>
<p>We need to add some new member variables.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="at">mutable</span> <span class="bu">std::</span>vector&lt;<span class="dt">size_t</span>&gt;             active_likelihood_index;</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="at">mutable</span> LikelihoodVector                conditional_likelihoods;</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="dt">size_t</span>                                  num_states;</span></code></pre></div>
<p>The <em>mutable</em> keyword says that you are allowed this change this variable even in a constant method. In that sense, it allows you to cheat. You should use this keyword only if it is really necessary.</p>
<p>Here we use the <em>mutable</em> keyword because we will fill the conditional likelihoods while we compute the probability, which is done by the function call to <em>lnProbability</em>, which is a constant function. We could instead make the function <em>lnProbability</em> non-constant.</p>
<p>Next, you might have noticed that the <em>conditional_likelihoods</em> are of type <em>LikelihoodVector</em>. This is not a standard C++ type; I have simply made it up similar to when I define a new class. So what is this the <em>LikelihoodVector</em>?</p>
<p>You have to declare this type</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">typedef</span> <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt; &gt; &gt; LikelihoodVector;</span></code></pre></div>
<p>It is simpler to use a <em>LikelihoodVector</em> than using a vector of a vector of a vector of a vector of doubles. But they are in fact identical. So it is just a different name that we define.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">void</span>                                    computeLnLikelihoodRecursively(<span class="at">const</span> TreeNode* n) <span class="at">const</span>;</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;       computeTransitionProbabilityMatrix(<span class="at">const</span> TreeNode* n) <span class="at">const</span>;</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="dt">void</span>                                    initializeConditionalLikelihoods(<span class="dt">void</span>);</span></code></pre></div>
<p>Let’s continue with the implementation which is in the file <strong>PhyloCTMC.cpp</strong>. Make sure to initialize <strong>num_states( 4 )</strong> in the constructor.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">/**</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co"> * Constructor of the PhyloCTMC.</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co"> *</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">phy</span><span class="co">         The phylogeny parameter.</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">q</span><span class="co">           The rate matrix parameter.</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co"> */</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>PhyloCTMC::PhyloCTMC(<span class="at">const</span> Tree* phy, <span class="at">const</span> RateMatrix_JC* q, <span class="dt">double</span>* cr) :</span>
<span id="cb6-8"><a href="#cb6-8"></a>    phylogeny( phy ),</span>
<span id="cb6-9"><a href="#cb6-9"></a>    Q( q ),</span>
<span id="cb6-10"><a href="#cb6-10"></a>    clock_rate( cr ),</span>
<span id="cb6-11"><a href="#cb6-11"></a>    num_states( <span class="dv">4</span> )</span>
<span id="cb6-12"><a href="#cb6-12"></a>{</span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a>}</span></code></pre></div>
<p>The main computations are performed in the recursive computation of the likelihoods.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">/**</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co"> * Recursively compute the ln likelihood for the given tree and parameters.</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co"> * Specifically, we compute the likelihood along the given branch, but make sure that we first compute likelihood for the two descendant branches</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co"> */</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="dt">void</span> PhyloCTMC::computeLnLikelihoodRecursively(<span class="at">const</span> TreeNode *node) <span class="at">const</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>{</span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="co">// to compute the likelihood, we need to get the likelihoods of our children first</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="co">// so get the two children</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    <span class="co">// this is safe even for tip nodes because the children will be NULL for tips</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="at">const</span> TreeNode* left_child    = node-&gt;getLeftChild();</span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="at">const</span> TreeNode* right_child   = node-&gt;getRightChild();</span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="co">// now check of this is a tip node</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>    <span class="cf">if</span> ( left_child != NULL &amp;&amp; right_child != NULL )</span>
<span id="cb7-16"><a href="#cb7-16"></a>    {</span>
<span id="cb7-17"><a href="#cb7-17"></a>        <span class="co">// if not, we need to compute the likelihoods along the two descendant branches</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>        <span class="co">// let&#39;s start with the indices of the nodes</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>        <span class="dt">size_t</span> node_index           = node-&gt;getIndex();</span>
<span id="cb7-20"><a href="#cb7-20"></a>        <span class="dt">size_t</span> left_child_index     = left_child-&gt;getIndex();</span>
<span id="cb7-21"><a href="#cb7-21"></a>        <span class="dt">size_t</span> right_child_index    = right_child-&gt;getIndex();</span>
<span id="cb7-22"><a href="#cb7-22"></a></span>
<span id="cb7-23"><a href="#cb7-23"></a>        <span class="co">// and recursively call this method to compute the likelihoods on the child branches</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>        computeLnLikelihoodRecursively( left_child );</span>
<span id="cb7-25"><a href="#cb7-25"></a>        computeLnLikelihoodRecursively( right_child );</span>
<span id="cb7-26"><a href="#cb7-26"></a></span>
<span id="cb7-27"><a href="#cb7-27"></a>        <span class="co">// now we can get the likelihood values, as stored in the conditional likelihood vectors</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>        <span class="at">const</span> <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;&amp; cl_left     = conditional_likelihoods[active_likelihood_index[left_child_index] ][left_child_index ];</span>
<span id="cb7-29"><a href="#cb7-29"></a>        <span class="at">const</span> <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;&amp; cl_right    = conditional_likelihoods[active_likelihood_index[right_child_index]][right_child_index];</span>
<span id="cb7-30"><a href="#cb7-30"></a>              <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;&amp; cl_node     = conditional_likelihoods[active_likelihood_index[node_index]       ][node_index       ];</span>
<span id="cb7-31"><a href="#cb7-31"></a></span>
<span id="cb7-32"><a href="#cb7-32"></a>        <span class="co">// don&#39;t forget that these represent the likelihoods at the beginning of the branches</span></span>
<span id="cb7-33"><a href="#cb7-33"></a>        <span class="co">// therefore, we need to get two transition probability matrices</span></span>
<span id="cb7-34"><a href="#cb7-34"></a>        <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt; transition_probabilities_left   = <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;();</span>
<span id="cb7-35"><a href="#cb7-35"></a>        <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt; transition_probabilities_right  = <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;();</span>
<span id="cb7-36"><a href="#cb7-36"></a></span>
<span id="cb7-37"><a href="#cb7-37"></a>        <span class="co">// now fill the transition probability matrices</span></span>
<span id="cb7-38"><a href="#cb7-38"></a>        transition_probabilities_left    = computeTransitionProbabilityMatrix(left_child);</span>
<span id="cb7-39"><a href="#cb7-39"></a>        transition_probabilities_right   = computeTransitionProbabilityMatrix(right_child);</span>
<span id="cb7-40"><a href="#cb7-40"></a></span>
<span id="cb7-41"><a href="#cb7-41"></a>        <span class="co">// iterate over all sites/columns of the alignment</span></span>
<span id="cb7-42"><a href="#cb7-42"></a>        <span class="dt">size_t</span> num_sites = value-&gt;getNumberOfSites();</span>
<span id="cb7-43"><a href="#cb7-43"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> c=<span class="dv">0</span>; c&lt;num_sites; c++)</span>
<span id="cb7-44"><a href="#cb7-44"></a>        {</span>
<span id="cb7-45"><a href="#cb7-45"></a>            <span class="co">// get the condition likelihood for this specific site</span></span>
<span id="cb7-46"><a href="#cb7-46"></a>            <span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; cl_left_site  = cl_left [c];</span>
<span id="cb7-47"><a href="#cb7-47"></a>            <span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; cl_right_site = cl_right[c];</span>
<span id="cb7-48"><a href="#cb7-48"></a>                  <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; cl_node_site  = cl_node [c];</span>
<span id="cb7-49"><a href="#cb7-49"></a></span>
<span id="cb7-50"><a href="#cb7-50"></a>            <span class="co">// if you were using among-site-rate-variation,</span></span>
<span id="cb7-51"><a href="#cb7-51"></a>            <span class="co">// then you need to iterate over all rate categories here</span></span>
<span id="cb7-52"><a href="#cb7-52"></a></span>
<span id="cb7-53"><a href="#cb7-53"></a>            <span class="co">// create two variables for the sum of probabilities for the left and right child</span></span>
<span id="cb7-54"><a href="#cb7-54"></a>            <span class="dt">double</span> sum_left = <span class="fl">0.0</span>, sum_right = <span class="fl">0.0</span>;</span>
<span id="cb7-55"><a href="#cb7-55"></a></span>
<span id="cb7-56"><a href="#cb7-56"></a>            <span class="co">// iterate over all possible starting states</span></span>
<span id="cb7-57"><a href="#cb7-57"></a>            <span class="cf">for</span> (<span class="dt">size_t</span> from=<span class="dv">0</span>; from&lt;num_states; from++)</span>
<span id="cb7-58"><a href="#cb7-58"></a>            {</span>
<span id="cb7-59"><a href="#cb7-59"></a>                <span class="co">// make sure that the sums are always 0.0 at the start</span></span>
<span id="cb7-60"><a href="#cb7-60"></a>                sum_left    = <span class="fl">0.0</span>;</span>
<span id="cb7-61"><a href="#cb7-61"></a>                sum_right   = <span class="fl">0.0</span>;</span>
<span id="cb7-62"><a href="#cb7-62"></a></span>
<span id="cb7-63"><a href="#cb7-63"></a>                <span class="co">// and then iterate over all end states</span></span>
<span id="cb7-64"><a href="#cb7-64"></a>                <span class="cf">for</span> (<span class="dt">size_t</span> to=<span class="dv">0</span>; to&lt;num_states; to++)</span>
<span id="cb7-65"><a href="#cb7-65"></a>                {</span>
<span id="cb7-66"><a href="#cb7-66"></a>                    <span class="co">// we add the probability that we started in i and terminated in j</span></span>
<span id="cb7-67"><a href="#cb7-67"></a>                    <span class="co">// multiplied with the probability that the child had state j</span></span>
<span id="cb7-68"><a href="#cb7-68"></a>                    sum_left   += transition_probabilities_left [from][to] * cl_left_site [to];</span>
<span id="cb7-69"><a href="#cb7-69"></a>                    sum_right  += transition_probabilities_right[from][to] * cl_right_site[to];</span>
<span id="cb7-70"><a href="#cb7-70"></a>                } <span class="co">// end for loop over all end states</span></span>
<span id="cb7-71"><a href="#cb7-71"></a></span>
<span id="cb7-72"><a href="#cb7-72"></a>                <span class="co">// to compute the likelihood of state i at this node,</span></span>
<span id="cb7-73"><a href="#cb7-73"></a>                <span class="co">// we need to multiply the likelihoods that we started with state i</span></span>
<span id="cb7-74"><a href="#cb7-74"></a>                <span class="co">// for both descendant branches</span></span>
<span id="cb7-75"><a href="#cb7-75"></a>                cl_node_site[from] = sum_left * sum_right;</span>
<span id="cb7-76"><a href="#cb7-76"></a></span>
<span id="cb7-77"><a href="#cb7-77"></a>            } <span class="co">// end for loop over all starting states</span></span>
<span id="cb7-78"><a href="#cb7-78"></a></span>
<span id="cb7-79"><a href="#cb7-79"></a></span>
<span id="cb7-80"><a href="#cb7-80"></a>        } <span class="co">// end for loop over all sites</span></span>
<span id="cb7-81"><a href="#cb7-81"></a></span>
<span id="cb7-82"><a href="#cb7-82"></a>    } <span class="co">// end-if this was a not a tip node</span></span>
<span id="cb7-83"><a href="#cb7-83"></a></span>
<span id="cb7-84"><a href="#cb7-84"></a>}</span></code></pre></div>
<p>Mostly for convenience, we break apart the transition probability computation in its own method. However, this makes our implementation of the Felsenstein’s pruning algorithm more generic because we can simply change the transition probability computation elsewhere.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">/**</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co"> * Compute the transition probability matrix for a given branch.</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co"> *</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">node</span><span class="co">                  The node/branch for which we need to compute the transition probability matrix.</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co"> * </span><span class="an">@return</span><span class="co">              A matrix, represented as a vector of a vector, of the transition probabilities.</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co"> */</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt; PhyloCTMC::computeTransitionProbabilityMatrix(<span class="at">const</span> TreeNode *node) <span class="at">const</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>{</span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="co">// most importantly, we need to get the length of the branch to represent the time of evolution</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="dt">double</span> branch_length = node-&gt;getBranchLength();</span>
<span id="cb8-11"><a href="#cb8-11"></a></span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="co">// we use a global clock rate</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="co">// this should be a variable to be estimated.</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="dt">double</span> c = <span class="fl">1.0</span>;</span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="cf">if</span> ( clock_rate != NULL)</span>
<span id="cb8-16"><a href="#cb8-16"></a>    {</span>
<span id="cb8-17"><a href="#cb8-17"></a>        c = *clock_rate;</span>
<span id="cb8-18"><a href="#cb8-18"></a>    }</span>
<span id="cb8-19"><a href="#cb8-19"></a></span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="co">// here is where you would introduce the site rates</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="dt">double</span> rate = c;</span>
<span id="cb8-22"><a href="#cb8-22"></a></span>
<span id="cb8-23"><a href="#cb8-23"></a>    <span class="cf">return</span> Q-&gt;calculateTransitionProbabilities(branch_length, rate);</span>
<span id="cb8-24"><a href="#cb8-24"></a>}</span></code></pre></div>
<p>You might have noticed that we never used tip states so far. This is done when we initialize the conditional likelihood vector.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">/**</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co"> * Initialize the vectors of conditional likelihoods</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co"> */</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="dt">void</span> PhyloCTMC::initializeConditionalLikelihoods( <span class="dt">void</span> )</span>
<span id="cb9-5"><a href="#cb9-5"></a>{</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="co">// for convenience, get a reference to the alignment so that we don&#39;t need to work with a pointer</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="at">const</span> Alignment&amp; alignment = *value;</span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="co">// how many nodes and sites do we have?</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="dt">size_t</span> n_nodes          = <span class="dv">2</span> * alignment.getNumberOfTaxa()-<span class="dv">1</span>;</span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="dt">size_t</span> n_sites          = alignment.getNumberOfSites();</span>
<span id="cb9-13"><a href="#cb9-13"></a></span>
<span id="cb9-14"><a href="#cb9-14"></a></span>
<span id="cb9-15"><a href="#cb9-15"></a>    <span class="co">// allocate conditional likelihoods</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>    conditional_likelihoods = <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">double</span> &gt; &gt; &gt; &gt;( <span class="dv">2</span>,</span>
<span id="cb9-17"><a href="#cb9-17"></a>                                <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">double</span>&gt; &gt; &gt;( n_nodes,</span>
<span id="cb9-18"><a href="#cb9-18"></a>                                    <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">double</span>&gt; &gt;(n_sites,</span>
<span id="cb9-19"><a href="#cb9-19"></a>                                        <span class="bu">std::</span>vector&lt; <span class="dt">double</span> &gt;( num_states, <span class="dv">0</span>) ) ) );</span>
<span id="cb9-20"><a href="#cb9-20"></a></span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="co">// initialize the tip conditional likelihoods</span></span>
<span id="cb9-22"><a href="#cb9-22"></a>    <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;alignment.getNumberOfTaxa(); i++)</span>
<span id="cb9-23"><a href="#cb9-23"></a>    {</span>
<span id="cb9-24"><a href="#cb9-24"></a>        <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;&amp; cl_0 = conditional_likelihoods[<span class="dv">0</span>][i];</span>
<span id="cb9-25"><a href="#cb9-25"></a>        <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;&amp; cl_1 = conditional_likelihoods[<span class="dv">1</span>][i];</span>
<span id="cb9-26"><a href="#cb9-26"></a>        <span class="cf">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j&lt;n_sites; j++)</span>
<span id="cb9-27"><a href="#cb9-27"></a>        {</span>
<span id="cb9-28"><a href="#cb9-28"></a>            <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; cl_0_site = cl_0[j];</span>
<span id="cb9-29"><a href="#cb9-29"></a>            <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; cl_1_site = cl_1[j];</span>
<span id="cb9-30"><a href="#cb9-30"></a>            <span class="dt">char</span> nuc = alignment.getNucleotide(i, j);</span>
<span id="cb9-31"><a href="#cb9-31"></a>            <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; states = alignment.getNucleotideStates(nuc);</span>
<span id="cb9-32"><a href="#cb9-32"></a></span>
<span id="cb9-33"><a href="#cb9-33"></a>            <span class="co">// if we were using among-site-rate variation,</span></span>
<span id="cb9-34"><a href="#cb9-34"></a>            <span class="co">// then we need to iterate here over the rate category too</span></span>
<span id="cb9-35"><a href="#cb9-35"></a>            <span class="cf">for</span> (<span class="dt">int</span> s=<span class="dv">0</span>; s&lt;num_states; s++)</span>
<span id="cb9-36"><a href="#cb9-36"></a>            {</span>
<span id="cb9-37"><a href="#cb9-37"></a>                cl_0_site[s] = (<span class="dt">double</span>)states[s];</span>
<span id="cb9-38"><a href="#cb9-38"></a>                cl_1_site[s] = (<span class="dt">double</span>)states[s];</span>
<span id="cb9-39"><a href="#cb9-39"></a>            }</span>
<span id="cb9-40"><a href="#cb9-40"></a>        }</span>
<span id="cb9-41"><a href="#cb9-41"></a>    }</span>
<span id="cb9-42"><a href="#cb9-42"></a></span>
<span id="cb9-43"><a href="#cb9-43"></a>    <span class="co">// also, allocate the vector of which likelihoods are active</span></span>
<span id="cb9-44"><a href="#cb9-44"></a>    active_likelihood_index = <span class="bu">std::</span>vector&lt;<span class="dt">size_t</span>&gt;(n_nodes,<span class="dv">0</span>);</span>
<span id="cb9-45"><a href="#cb9-45"></a>}</span></code></pre></div>
<p>Finally, we can put the Felsenstein’s pruning algorithm together to compute the joint probability of all sites, which is our probability of observing the alignment.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="co">/**</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"> * Compute the log-probability of the values given the CTMC process.</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co"> *</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co"> * The main idea for computing the probability of the alignment is to use a recursive version of Felsenstein&#39;s pruning algorithm.</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co"> * We also assume that each site is i.i.d., and therefore multiply the probabilities for all sites together.</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="co"> *</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="co"> * </span><span class="an">@return</span><span class="co">              Returns the log-probability.</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="co"> */</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="dt">double</span> PhyloCTMC::lnProbability( <span class="dt">void</span> ) <span class="at">const</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>{</span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="co">// initialize the log probability</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="dt">double</span> ln_prob = <span class="fl">0.0</span>;</span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="co">// for the recursive computation, we start with the root node.</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="at">const</span> TreeNode *root = phylogeny-&gt;getRootNode();</span>
<span id="cb10-16"><a href="#cb10-16"></a>    <span class="dt">size_t</span> root_index = root-&gt;getIndex();</span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="co">// start the computation of the conditional likelihoods recursively</span></span>
<span id="cb10-19"><a href="#cb10-19"></a>    computeLnLikelihoodRecursively( root );</span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a>    <span class="co">// get the prior probabilities for the root states</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="co">// in the Jukes-Cantor model these are equal probabilities.</span></span>
<span id="cb10-23"><a href="#cb10-23"></a>    <span class="co">// Otherwise, they are given by the stationary frequencies,</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>    <span class="co">// which should be a parameter here too then</span></span>
<span id="cb10-25"><a href="#cb10-25"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; f = <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;(num_states, <span class="fl">1.0</span>/num_states);</span>
<span id="cb10-26"><a href="#cb10-26"></a>    <span class="co">//    const std::vector&lt;double&gt;&amp; f = *stationary_frequencies;</span></span>
<span id="cb10-27"><a href="#cb10-27"></a></span>
<span id="cb10-28"><a href="#cb10-28"></a>    <span class="co">// now get the conditional likelihoods at the root node</span></span>
<span id="cb10-29"><a href="#cb10-29"></a>    <span class="at">const</span> <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;&amp; cl_node = conditional_likelihoods[active_likelihood_index[root_index] ][root_index];</span>
<span id="cb10-30"><a href="#cb10-30"></a></span>
<span id="cb10-31"><a href="#cb10-31"></a>    <span class="co">//    double category_prob = 1.0 / num_gamma_categories;</span></span>
<span id="cb10-32"><a href="#cb10-32"></a>    <span class="co">// iterate over all sites</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>    <span class="dt">size_t</span> num_sites = value-&gt;getNumberOfSites();</span>
<span id="cb10-34"><a href="#cb10-34"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> c=<span class="dv">0</span>; c&lt;num_sites; c++)</span>
<span id="cb10-35"><a href="#cb10-35"></a>    {</span>
<span id="cb10-36"><a href="#cb10-36"></a>        <span class="co">// compute the probability for this site</span></span>
<span id="cb10-37"><a href="#cb10-37"></a>        <span class="dt">double</span> site_prob = <span class="fl">0.0</span>;</span>
<span id="cb10-38"><a href="#cb10-38"></a></span>
<span id="cb10-39"><a href="#cb10-39"></a>        <span class="co">// get the conditional likelihood for this specific site</span></span>
<span id="cb10-40"><a href="#cb10-40"></a>        <span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&amp; cl_site = cl_node[c];</span>
<span id="cb10-41"><a href="#cb10-41"></a></span>
<span id="cb10-42"><a href="#cb10-42"></a>        <span class="co">// and compute the weighted sum</span></span>
<span id="cb10-43"><a href="#cb10-43"></a>        <span class="co">// if we allow for among-site-rate-variation, we need to sum over the rate categories here too</span></span>
<span id="cb10-44"><a href="#cb10-44"></a>        <span class="co">// and weight them by the prior for the rate category (usually assumed to be equal -&gt; 1/n)</span></span>
<span id="cb10-45"><a href="#cb10-45"></a></span>
<span id="cb10-46"><a href="#cb10-46"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> j=<span class="dv">0</span>; j&lt;num_states; j++)</span>
<span id="cb10-47"><a href="#cb10-47"></a>        {</span>
<span id="cb10-48"><a href="#cb10-48"></a>            site_prob += cl_site[j] * f[j];</span>
<span id="cb10-49"><a href="#cb10-49"></a>        }</span>
<span id="cb10-50"><a href="#cb10-50"></a></span>
<span id="cb10-51"><a href="#cb10-51"></a>        <span class="co">// add the log-probability for this site to our overall probability</span></span>
<span id="cb10-52"><a href="#cb10-52"></a>        ln_prob += log(site_prob);</span>
<span id="cb10-53"><a href="#cb10-53"></a>    }</span>
<span id="cb10-54"><a href="#cb10-54"></a></span>
<span id="cb10-55"><a href="#cb10-55"></a>    <span class="co">// return the computed log probability</span></span>
<span id="cb10-56"><a href="#cb10-56"></a>    <span class="cf">return</span> ln_prob;</span>
<span id="cb10-57"><a href="#cb10-57"></a>}</span></code></pre></div>
<p>Last time we didn’t add the <em>setValue</em> method, so we need to it now. Importantly, when the value/alignment has been set, we can initialize the condition likelihoods.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="dt">void</span> PhyloCTMC::setValue(<span class="at">const</span> Alignment *x)</span>
<span id="cb11-2"><a href="#cb11-2"></a>{</span>
<span id="cb11-3"><a href="#cb11-3"></a>    value = x;</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>    initializeConditionalLikelihoods();</span>
<span id="cb11-6"><a href="#cb11-6"></a>}</span></code></pre></div>
<p>Finally, you can put everything together and test it in your main function. You should write the following lines into your <strong>main.cpp</strong> file.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">// read in some trees</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>NewickTreeReader tree_reader = NewickTreeReader();</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="bu">std::</span>vector&lt;Tree&gt; trees = tree_reader.readTrees(<span class="st">&quot;primates.tre&quot;</span>);</span>
<span id="cb12-4"><a href="#cb12-4"></a>Tree* my_tree = <span class="kw">new</span> Tree(trees[<span class="dv">0</span>]);</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co">// create a transition rate matrix</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>RateMatrix_JC *my_rate_matrix = <span class="kw">new</span> RateMatrix_JC();</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="co">// create a transition rate matrix</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="dt">double</span> *my_clock_rate = <span class="kw">new</span> <span class="dt">double</span>(<span class="fl">1.0</span>);</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a>PhyloCTMC ctmc = PhyloCTMC( my_tree, my_rate_matrix, my_clock_rate );</span>
<span id="cb12-13"><a href="#cb12-13"></a></span>
<span id="cb12-14"><a href="#cb12-14"></a>AlignmentReader reader;</span>
<span id="cb12-15"><a href="#cb12-15"></a>Alignment* my_alignment = <span class="kw">new</span> Alignment( reader.readPhylip( <span class="st">&quot;primates.phy&quot;</span> ) );</span>
<span id="cb12-16"><a href="#cb12-16"></a>ctmc.setValue( my_alignment );</span>
<span id="cb12-17"><a href="#cb12-17"></a></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="dt">double</span> likelihood = ctmc.lnProbability();</span>
<span id="cb12-19"><a href="#cb12-19"></a></span>
<span id="cb12-20"><a href="#cb12-20"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;ln(likelihood) = &quot;</span> &lt;&lt; likelihood &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb12-21"><a href="#cb12-21"></a></span>
<span id="cb12-22"><a href="#cb12-22"></a><span class="kw">delete</span> my_alignment;</span>
<span id="cb12-23"><a href="#cb12-23"></a><span class="kw">delete</span> my_rate_matrix;</span>
<span id="cb12-24"><a href="#cb12-24"></a><span class="kw">delete</span> my_tree;</span></code></pre></div>
<h2 id="section-6.xxx-exercises">Section 6.xxx: Exercises</h2>
<h3 id="section-6.xxx.1-compute-the-likelihood-under-the-f81-substitution-model">Section 6.xxx.1: Compute the likelihood under the F81 substitution model</h3>
<p>Replace the Jukes-Cantor substitution matrix in the <em>PhyloCTMC</em> class and use the F81 substitution model instead. Don’t forget to add another parameter to the <em>PhyloCTMC</em> class for the stationary frequencies, we should be the same parameter as used in the F81 class.</p>
<h3 id="section-6.xxx.2-add-among-site-rate-variation-using-a-discretize-gamma-distribution">Section 6.xxx.2: Add among site rate variation using a discretize Gamma distribution</h3>
<p>In our first implementation, we assumed that all sites evolve under the exactly same rate of evolution. However, this is often a terrible assumption. For example, nucleotides at the first codon position are often more conserved than nucleotides at the third codon position. Therefore, we should allow for some rate variation across sites. Commonly, researchers assume that rates for sites are drawn from a gamma distribution. To make computations easier, we actually integrate over this distribution by discretization.</p>
<p>In your code, you can compute the rate categories using</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="dt">double</span> q = (cat_index+<span class="fl">0.5</span>) / <span class="dt">double</span>(num_gamma_categories);</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="dt">double</span> site_rate = Statistics::Gamma::quantile(alpha, alpha, q);</span></code></pre></div>
<p>For this computation you need to use the two additional class <strong>Math</strong> and <strong>Statistics</strong>. I provided these because they include a lot of technical details that are not of primary interest here.</p>
<p>You also need to change the code to use one additional layer in the conditional likelihood vectors. Generally speaking, you need to have one likelihood vector for each of the rate categories. Thus, you should initialize the conditional likelihoods with</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a>    conditional_likelihoods = <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">double</span> &gt; &gt; &gt; &gt; &gt;( <span class="dv">2</span>,</span>
<span id="cb14-2"><a href="#cb14-2"></a>                                <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">double</span>&gt; &gt; &gt; &gt;( n_nodes,</span>
<span id="cb14-3"><a href="#cb14-3"></a>                                    <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">double</span>&gt; &gt; &gt;(n_sites,</span>
<span id="cb14-4"><a href="#cb14-4"></a>                                        <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>vector&lt; <span class="dt">double</span> &gt; &gt;( num_gamma_categories,</span>
<span id="cb14-5"><a href="#cb14-5"></a>                                            <span class="bu">std::</span>vector&lt; <span class="dt">double</span> &gt;( num_states, <span class="dv">0</span>) ) ) ) );</span></code></pre></div>
<p>Make the other changes that you iterate over the rate categories where indicate.</p>
<div>
<h2 id="references">References</h2>
</div>
</body>
</html>
