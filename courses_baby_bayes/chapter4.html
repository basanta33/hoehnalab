---
layout: chapter
title: Simulating Random Trees
output:
  html_document:
    toc: true
    toc_float: true
pdf: true
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Simulating Random Trees</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Simulating Random Trees</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter-4-simulating-trees">Chapter 4: Simulating Trees</a><ul>
<li><a href="#section-4.1-the-random-number-generator">Section 4.1: The random number generator</a><ul>
<li><a href="#subsection-4.1.1-the-randomnumbergenerator.h-file">Subsection 4.1.1: The <em>RandomNumberGenerator.h</em> file</a></li>
<li><a href="#subsection-4.1.2-the-randomnumbergenerator.cpp-file">Subsection 4.1.2: The <em>RandomNumberGenerator.cpp</em> file</a></li>
</ul></li>
<li><a href="#section-4.2-the-pure-birth-process">Section 4.2: The pure birth process</a><ul>
<li><a href="#subsection-4.2.1-the-purebirthprocess.h-file">Subsection 4.2.1: The <em>PureBirthProcess.h</em> file</a></li>
<li><a href="#subsection-4.2.2-the-purebirthprocess.cpp-file">Subsection 4.2.2: The <em>PureBirthProcess.cpp</em> file</a></li>
</ul></li>
<li><a href="#section-4.4-putting-it-together">Section 4.4: Putting it together</a></li>
<li><a href="#section-4.5-exercises">Section 4.5: Exercises</a><ul>
<li><a href="#subsection-4.5.1-how-random-are-the-random-numbers">Subsection 4.5.1: How random are the random numbers</a></li>
<li><a href="#subsection-4.5.2-implement-another-random-number-generator">Subsection 4.5.2: Implement another random number generator</a></li>
<li><a href="#subsection-4.5.3-implement-a-birth-death-process">Subsection 4.5.3: Implement a birth-death process</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<div>
<p><a href="{{site.baseurl}}/pdf/chapter4.pdf">pdf version</a></p>
</div>
<h1 id="chapter-4-simulating-trees">Chapter 4: Simulating Trees</h1>
<h2 id="section-4.1-the-random-number-generator">Section 4.1: The random number generator</h2>
<p>In this chapter, we need a random number generator. As it turns out, computers can’t generate randomness on their own. All they can do is logical operations and math. So, how do we make randomness from one of the most deterministic tools made by man? The answer is that we don’t. Rather, we generate sequences of numbers that in many respects behave randomly. To be more correct, I will modify my original statement: In this chapter, we are going to make a <em>pseudo</em> random number generator.</p>
<p>The sequence of pseudorandom numbers is completely determined by the initial value, called the seed. If we initialize the pseudorandom number generator with the same seed, we will get the same sequence out. If the sequence of random numbers revisits the value for the seed, it will repeat. The period of the pseudorandom number is the length of this repeat. Good pseudorandom number generators will have a very long period. Moreover, the values will be difficult to distinguish from truly random numbers. For example, they shouldn’t be correlated with previous values.</p>
<p>You should be wary of using pseudorandom number generators. There is an entire sub-discipline in computer science dedicated to developing better pseudorandom numbers.</p>
<p>We will implement a simple linear congruential generator described by <span class="citation" data-cites="park88">(Park and Miller <a href="#ref-park88" role="doc-biblioref">1988</a>)</span>. It is not a state-of-the-art pseudorandom number generator, but it will give you an idea of how apparent randomness can be generated on a computer. It should be good enough for the applications in this book.</p>
<p>A linear congruential generator starts with an initial value of an <em>int</em> variable called the seed. The seed value is changed sequentially using the following equation: <span class="math display">\[
s_{i+1} = (a \times s_i + c) \mod m
\]</span> where <span class="math inline">\(s_i\)</span> is the <span class="math inline">\(i\)</span>th value of the seed, <span class="math inline">\(a\)</span> is the multiplier, <span class="math inline">\(c\)</span> is the increment, and <span class="math inline">\(m\)</span> is the modulus. Good pseudorandom number generators that use the linear congruential generator choose <span class="math inline">\(a\)</span>, <span class="math inline">\(c\)</span>, and <span class="math inline">\(m\)</span> wisely. The seed value for a good choice of <span class="math inline">\(a\)</span>, <span class="math inline">\(c\)</span>, and <span class="math inline">\(m\)</span> will bounce between 1 and the maximum value possible in a way that has the appearance of randomness.</p>
<h3 id="subsection-4.1.1-the-randomnumbergenerator.h-file">Subsection 4.1.1: The <em>RandomNumberGenerator.h</em> file</h3>
<p>Let us start, as usual, by creating the definition of the random number generator. Create a new file called <strong>RandomNumberGenerator.h</strong>. In this file, write the following class definition.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#ifndef RandomNumberGenerator_h</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#define RandomNumberGenerator_h</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">/**</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co"> * </span><span class="an">\class</span><span class="co"> </span><span class="cv">RandomNumberGenerator</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"> *</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co"> * </span><span class="an">\brief</span><span class="co"> Draw a random number between 0 and 1.</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co"> *</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co"> * The random number generator draws values in the range between 0 and 1.</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co"> *</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co"> *</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co"> *</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co"> * </span><span class="an">\author</span><span class="co"> Sebastian Höhna</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="co"> *</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="co"> */</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="kw">class</span> RandomNumberGenerator {</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="kw">public</span>:</span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>    RandomNumberGenerator(<span class="dt">void</span>);</span>
<span id="cb1-24"><a href="#cb1-24"></a>    RandomNumberGenerator(<span class="dt">int</span> x);</span>
<span id="cb1-25"><a href="#cb1-25"></a></span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="co">// Regular functions</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>    <span class="dt">double</span>                              uniform01(<span class="dt">void</span>);</span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="kw">private</span>:</span>
<span id="cb1-30"><a href="#cb1-30"></a>    <span class="dt">int</span>                                 seed;</span>
<span id="cb1-31"><a href="#cb1-31"></a></span>
<span id="cb1-32"><a href="#cb1-32"></a>};</span>
<span id="cb1-33"><a href="#cb1-33"></a></span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="pp">#endif </span><span class="co">/* RandomNumberGenerator_h */</span></span></code></pre></div>
<p>Overall, this class definition is fairly simple. We have two constructors, one without a user-provided seed and one with a user-provided seed. The <em>seed</em> variable is stored privately in this class. The only actual function which the random number generator provides is the <em>uniform01</em> method. This method, as its name suggests, draws (pseudo-)random numbers in the range between 0 and 1. This is all that is usually needed. As we see later in this chapter, we can transform uniform01 random variables into random draws from an exponential distribution.</p>
<h3 id="subsection-4.1.2-the-randomnumbergenerator.cpp-file">Subsection 4.1.2: The <em>RandomNumberGenerator.cpp</em> file</h3>
<p>Now let’s implement the random number generator. Create a new file called <strong>RandomNumberGenerator.cpp</strong>.</p>
<p>First, add the include statements.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&quot;RandomNumberGenerator.h&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;ctime&gt;</span><span class="pp">        </span><span class="co">// needed for time()</span></span></code></pre></div>
<p>The first include statement should be familiar to you; we include the definition of the class that we want to implement. The second include statement provides us with a function to call the system time.</p>
<p>Our implementation of the default constructor sets the <em>seed</em> variable to be equal to the current time, obtained using the <em>time</em> function. The variable that is returned by the <em>time</em> function is not an <em>int</em> variable, so we cannot directly equate it to <em>seed</em>. The <em>time</em> function returns a variable of type <em>time_t</em>. However, we can force the <em>time_t</em> variable to act as an <em>int</em> using the casting argument, which was the <em>(int)</em> before the <em>time(NULL)</em>. Casting can be dangerous. You can’t always sensibly cast one variable type into another. In this case, however, you can sensibly cast a <em>time_t</em> variable into an <em>int</em> variable. All is well.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">/**</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co"> * Constructor for RandomNumberGenerator class. This constructor does not take</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co"> * any parameters and initializes the seed using the current</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"> * system time.</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co"> *</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co"> */</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>RandomNumberGenerator::RandomNumberGenerator(<span class="dt">void</span>)</span>
<span id="cb3-8"><a href="#cb3-8"></a>{</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="co">// initialize the seed with the system time</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    seed = (<span class="dt">int</span>)( time( <span class="dv">0</span> ) );</span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a>}</span></code></pre></div>
<p>Our second constructor takes in a user-provided seed. This makes it much simpler and only set the private class variable for the seed.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">/**</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co"> * Constructor for RandomNumberGenerator class which takes as a</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co"> * parameter an integer with the user-supplied seed for the</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co"> * random number generator.</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co"> *</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">x</span><span class="co">           is an integer with the user-supplied random number seed.</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co"> */</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>RandomNumberGenerator::RandomNumberGenerator(<span class="dt">int</span> x)</span>
<span id="cb4-9"><a href="#cb4-9"></a>{</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a>    seed = x;</span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a>}</span></code></pre></div>
<p>Now we turn to the only really interesting function: the <em>uniform01</em>. The code for pseudorandom number generators is always disturbing to look at. The non-randomness of a pseudorandom number generator sort of smacks you in the face when you see the code. You should be feeling a little queasy at this point.</p>
<p>Clearly, the <em>seed</em> variable is changed every time the <em>uniform01</em> function is called. The number that is returned is the new value for the seed divided by its maximum possible value. We use casting, again, to force the compiler to treat seed as a double (real-valued number) when the division occurs in the last line. If we didn’t do this, the function would return 0 every time.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">/**</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co"> * This function generates a uniformly-distributed random variable on the interval [0,1).</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co"> * It is a version of simple linear congruential generator.</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co"> *</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co"> *</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co"> * </span><span class="an">@return</span><span class="co">                  Returns a uniformly-distributed random variable on the interval [0,1).</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co"> *</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co"> */</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="dt">double</span> RandomNumberGenerator::uniform01(<span class="dt">void</span>)</span>
<span id="cb5-10"><a href="#cb5-10"></a>{</span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="co">// Returns a pseudo-random number between 0 and 1.</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="dt">int</span> hi = seed / <span class="dv">127773</span>;</span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="dt">int</span> lo = seed % <span class="dv">127773</span>;</span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="dt">int</span> test = <span class="dv">16807</span> * lo - <span class="dv">2836</span> * hi;</span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="cf">if</span> (test &gt; <span class="dv">0</span>)</span>
<span id="cb5-17"><a href="#cb5-17"></a>        seed = test;</span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="cf">else</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>        seed = test + <span class="dv">2147483647</span>;</span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a>    <span class="cf">return</span> (<span class="dt">double</span>)(seed) / (<span class="dt">double</span>)<span class="dv">2147483647</span>;</span>
<span id="cb5-22"><a href="#cb5-22"></a></span>
<span id="cb5-23"><a href="#cb5-23"></a>}</span></code></pre></div>
<p>You now finished writing your own random number generator. You should explore this random number generator a bit more and try the exercises.</p>
<h2 id="section-4.2-the-pure-birth-process">Section 4.2: The pure birth process</h2>
<p>The birth-death process of cladogenesis is widely-used in evolutionary biology to model the Tree of Life. The process models the splitting (speciation) and termination (extinction) of lineages through time. The probability of a speciation event occurring in an infinitesimal interval of time, <span class="math inline">\(\Delta t\)</span>, is <span class="math inline">\(\lambda \Delta t\)</span> whereas the probability of an extinction event occurring in the same infinitesimal interval of time is <span class="math inline">\(\mu \Delta t\)</span>. This implies that the time between speciation <em>or</em> extinction events is exponentially distributed with parameter <span class="math inline">\(\lambda + \mu\)</span>. When an event occurs, it is a speciation with probability <span class="math inline">\(\frac{\lambda}{\lambda + \mu}\)</span> or an extinction with probability <span class="math inline">\(\frac{\mu}{\lambda + \mu}\)</span>.</p>
<p>Birth-death processes are used for two main purposes in evolutionary biology: (1) they are used to estimate speciation and extinction rates to study macroevolutionary questions. (2) they are used as prior distributions on phylogenetic trees in Bayesian phylogenetic analyses. Here, we use the birth-death process for the second scenario as a prior distribution.</p>
<p>To make things a bit simpler in the beginning, we will start with the pure birth process, sometime also called the <em>Yule</em> process. The pure birth process is a birth-death process where the extinction (or death) rate is equal to zero. Extinction events are not allowed to happen. This makes simulation and probability computation a fair bit easier. We have added all information to change the code and write a birth-death process as an exercise.</p>
<h3 id="subsection-4.2.1-the-purebirthprocess.h-file">Subsection 4.2.1: The <em>PureBirthProcess.h</em> file</h3>
<p>Create a new file called <strong>PureBirthProcess.h</strong>. In this file, we will add the following definition of the pure birth process.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#ifndef PureBirthProcess_h</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#define PureBirthProcess_h</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="pp">#include </span><span class="im">&quot;RandomNumberGenerator.h&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">// forward declaration(s)</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">class</span> Tree;</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">/**</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co"> * </span><span class="an">\class</span><span class="co"> </span><span class="cv">PureBirthProcess</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co"> *</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co"> * </span><span class="an">\brief</span><span class="co"> A pure birth process for simulating trees and computing probabilities.</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co"> *</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="co"> * This class represents a pure birth process where birth/speciation events</span></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co"> * occur after an exponential distributed waiting time.</span></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="co"> * There are no death/extinction events.</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="co"> * The two main functions in this class are the rv function to simulate trees</span></span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="co"> * and the lnProbability function to compute the log-probability of a given tree.</span></span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="co"> *</span></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="co"> *</span></span>
<span id="cb6-24"><a href="#cb6-24"></a><span class="co"> * </span><span class="an">\author</span><span class="co"> Sebastian Höhna</span></span>
<span id="cb6-25"><a href="#cb6-25"></a><span class="co"> *</span></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="co">*/</span></span>
<span id="cb6-27"><a href="#cb6-27"></a><span class="kw">class</span> PureBirthProcess {</span>
<span id="cb6-28"><a href="#cb6-28"></a></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="kw">public</span>:</span>
<span id="cb6-30"><a href="#cb6-30"></a>    PureBirthProcess(<span class="at">const</span> <span class="dt">double</span> *b);</span>
<span id="cb6-31"><a href="#cb6-31"></a>    <span class="kw">virtual</span>                    ~PureBirthProcess();</span>
<span id="cb6-32"><a href="#cb6-32"></a></span>
<span id="cb6-33"><a href="#cb6-33"></a>    <span class="dt">double</span>                      lnProbability(<span class="dt">void</span>) <span class="at">const</span> ;</span>
<span id="cb6-34"><a href="#cb6-34"></a>    Tree*                       rv(RandomNumberGenerator *rng, <span class="dt">double</span> age);</span>
<span id="cb6-35"><a href="#cb6-35"></a>    <span class="dt">void</span>                        setValue(<span class="at">const</span> Tree *x);</span>
<span id="cb6-36"><a href="#cb6-36"></a></span>
<span id="cb6-37"><a href="#cb6-37"></a><span class="kw">protected</span>:</span>
<span id="cb6-38"><a href="#cb6-38"></a></span>
<span id="cb6-39"><a href="#cb6-39"></a>    <span class="at">const</span> <span class="dt">double</span>*               birth_rate;</span>
<span id="cb6-40"><a href="#cb6-40"></a>    <span class="at">const</span> Tree*                 value;</span>
<span id="cb6-41"><a href="#cb6-41"></a></span>
<span id="cb6-42"><a href="#cb6-42"></a>};</span>
<span id="cb6-43"><a href="#cb6-43"></a></span>
<span id="cb6-44"><a href="#cb6-44"></a><span class="pp">#endif </span><span class="co">/* PureBirthProcess_h */</span></span></code></pre></div>
<p>Our class has two member variables which are both constant pointers. A constant pointer written in this way, e.g., <em>double*</em>, means that the value at the memory address cannot be changeg. We still can replace the pointer with a new one. We usually use constant pointers to signal that we do not own the pointer. We are going to need values written at the memory addresses of these pointers, but we are not going to change the values. Our model class will be responsible for the memory and changing the values.</p>
<p>Here, the three important function are <em>lnProbability</em>, <em>rv</em> and <em>setValue</em>. We will cover each one of them in detail in the implementation.</p>
<h3 id="subsection-4.2.2-the-purebirthprocess.cpp-file">Subsection 4.2.2: The <em>PureBirthProcess.cpp</em> file</h3>
<p>Create a new file called <strong>PureBirthProcess.cpp</strong>. Start by adding the include statements.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&quot;PureBirthProcess.h&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&quot;Tree.h&quot;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#include </span><span class="im">&quot;TreeNode.h&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span></code></pre></div>
<p>Next, we will add the constructor. This constructor will simply set the birth rate variable but otherwise will do nothing.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">/**</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co"> * Constructor of the PureBirthProcess.</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co"> *</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">n</span><span class="co">           The taxon names used for the tips.</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">b</span><span class="co">           The birth rate parameter.</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co"> */</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>PureBirthProcess::PureBirthProcess(<span class="at">const</span> <span class="dt">double</span> *b) :</span>
<span id="cb8-8"><a href="#cb8-8"></a>    birth_rate( b )</span>
<span id="cb8-9"><a href="#cb8-9"></a>{</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a>}</span></code></pre></div>
<p>As good practice, we will also add the destructor although it is not actually doing anything. In this case here, it is nice to have the destructor because it makes it clear that the member variables which are pointers do not point to memory that this class needs to clean up.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">/**</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co"> * Destructor of the pure birth process.</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co"> */</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>PureBirthProcess::~PureBirthProcess( <span class="dt">void</span> )</span>
<span id="cb9-5"><a href="#cb9-5"></a>{</span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="co">// we do not own the rate parameter nor the value, so we have nothing to delete</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>}</span></code></pre></div>
<p>The probability of a tree under the pure birth process is computed by two parts: (1) computing the probability of the waiting time until the next event, and (2) computing the probability density of the actual events, the birth events. As we mentioned in the beginning of this chapter, waiting times under the birth-death process are exponentially distributed. Since we have here only birth events, the waiting time is simply exponentiall distributed. So we can say that the probability along a branch is computed by <span class="math inline">\(e^{-\lambda t}\)</span> where <span class="math inline">\(\lambda\)</span> is the birth rate. The probability density of the birth events themselves is <span class="math inline">\(\lambda\)</span>.</p>
<p>Putting this together, we need to compute the waiting time along each branch, and the probability <span class="math inline">\(\lambda\)</span> for each birth event. That’s all!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="co">/**</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"> * Compute the log-probability of the values given the birth rate.</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co"> *</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co"> * The algorithm here is to get all branches of the tree and compute the</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co"> * probability of nothing happening along the branch and the</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="co"> * speciation/birth event at the end of the branch.</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="co"> *</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="co"> * </span><span class="an">@return</span><span class="co">              Returns the log-probability.</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="co"> */</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="dt">double</span> PureBirthProcess::lnProbability( <span class="dt">void</span> ) <span class="at">const</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>{</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="co">// initialize the log probability</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="dt">double</span> ln_prob = <span class="fl">0.0</span>;</span>
<span id="cb10-14"><a href="#cb10-14"></a></span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="co">// for simplicity of use, store the birth-rate as a local double variable</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>    <span class="dt">double</span> l = *birth_rate;</span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="co">// get all the nodes of the tree</span></span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="at">const</span> <span class="bu">std::</span>vector&lt;TreeNode*&gt; &amp;nodes = value-&gt;getNodes();</span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a>    <span class="co">// iterate over all the nodes to get the branch lengths</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;nodes.size(); i++)</span>
<span id="cb10-23"><a href="#cb10-23"></a>    {</span>
<span id="cb10-24"><a href="#cb10-24"></a>        <span class="co">// get the current node</span></span>
<span id="cb10-25"><a href="#cb10-25"></a>        TreeNode *node = nodes[i];</span>
<span id="cb10-26"><a href="#cb10-26"></a></span>
<span id="cb10-27"><a href="#cb10-27"></a>        <span class="co">// make sure that it is not the root node</span></span>
<span id="cb10-28"><a href="#cb10-28"></a>        <span class="cf">if</span> ( node-&gt;isRoot() == <span class="kw">false</span> )</span>
<span id="cb10-29"><a href="#cb10-29"></a>        {</span>
<span id="cb10-30"><a href="#cb10-30"></a>            <span class="co">// get the current branch length</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>            <span class="dt">double</span> bl = node-&gt;getBranchLength();</span>
<span id="cb10-32"><a href="#cb10-32"></a>            <span class="co">// add the log-probability of no event along the branch (-l*bl)</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>            ln_prob -= l * bl;</span>
<span id="cb10-34"><a href="#cb10-34"></a>            <span class="co">// the log-probability density for the event itself: log(l)</span></span>
<span id="cb10-35"><a href="#cb10-35"></a>            <span class="cf">if</span> ( node-&gt;isTip() == <span class="kw">false</span> )</span>
<span id="cb10-36"><a href="#cb10-36"></a>            {</span>
<span id="cb10-37"><a href="#cb10-37"></a>                ln_prob += <span class="bu">std::</span>log(l);</span>
<span id="cb10-38"><a href="#cb10-38"></a>            }</span>
<span id="cb10-39"><a href="#cb10-39"></a>        }</span>
<span id="cb10-40"><a href="#cb10-40"></a></span>
<span id="cb10-41"><a href="#cb10-41"></a>    } <span class="co">// end for loop over all nodes</span></span>
<span id="cb10-42"><a href="#cb10-42"></a></span>
<span id="cb10-43"><a href="#cb10-43"></a>    <span class="co">// return the computed log probability</span></span>
<span id="cb10-44"><a href="#cb10-44"></a>    <span class="cf">return</span> ln_prob;</span>
<span id="cb10-45"><a href="#cb10-45"></a>}</span></code></pre></div>
<p>Our second function that is more intricate is the simulator under the pure birth process. The idea of the algorithm is that we start at some time in the past and keep on simulating until we reach the present time, denoted by <span class="math inline">\(age = 0\)</span>. At the root, we will start with two nodes, the two children of the root node. We will keep track of the the active nodes, which are the current lineages alive in the simulation that do not have descendants. Since each of the lineages has the same rate until an event occurs, we can sum the rates together by using <span class="math inline">\(num\_nodes * \lambda\)</span>. Then, we need to consider how the exponential distribution works for drawing random waiting times.</p>
<p>The exponential probability distribution accurately models the waiting time until an event occurs when that event occurs at a constant rate, <span class="math inline">\(\lambda\)</span>. The exponential probability distribution is a continuous distribution with density function, <span class="math inline">\(f(t) = \lambda e^{-\lambda t}\)</span>, for <span class="math inline">\(t &gt; 0, \lambda &gt; 0\)</span>. How can we generate an exponentially-distributed random number?</p>
<p>The idea is to transform the uniform(0,1) random variable into an exponential(<span class="math inline">\(\lambda\)</span>) random variable. We know that if we integrate over all possible values of <span class="math inline">\(t\)</span>, that the overall probability is one ({}, the exponential is a probability distribution): <span class="math display">\[
\int_0^{\infty} \lambda e^{-\lambda x} dx = 1
\]</span> The key to transforming our uniform into an exponential is to generate a uniform(0,1) random variable called <span class="math inline">\(u\)</span> and set the integral equal to that value: <span class="math display">\[
\int_0^{t} \lambda e^{-\lambda x} dx = u
\]</span> We can solve for <span class="math inline">\(t\)</span> as follows: <span class="math display">\[\begin{eqnarray*}
\int_0^{t} \lambda e^{-\lambda x} dx &amp; = &amp; u \\
-e^{-\lambda x} \Big|_0^t &amp; = &amp; u \\
-e^{-\lambda t} - -e^{0} &amp; = &amp; u \\
1 - -e^{-\lambda t} &amp; = &amp; u \\
e^{-\lambda t} &amp; = &amp; 1 - u \\
-\lambda t &amp; = &amp; \ln(1 - u) \\
t &amp; = &amp; -\frac{1}{\lambda} \ln(1-u)
\end{eqnarray*}\]</span> Here, <span class="math inline">\(t\)</span> is an exponential(<span class="math inline">\(\lambda\)</span>) random variable. It was obtained by transforming our uniform(0,1) random variable, <span class="math inline">\(u\)</span>. Equivalently, we could use the equation <span class="math inline">\(t = -\frac{1}{\lambda} \ln(u)\)</span>.</p>
<p>So let’s see how this plays together.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">/**</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co"> * Draw a random tree from a birth death process.</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co"> *</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">rng</span><span class="co">         The random number generator used for the simulation.</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co"> * </span><span class="an">@return</span><span class="co">              The random tree.</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co"> */</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>Tree* PureBirthProcess::rv(RandomNumberGenerator *rng, <span class="dt">double</span> age)</span>
<span id="cb11-8"><a href="#cb11-8"></a>{</span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="co">// prepare some variables, such as the birth rate</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="dt">double</span> l = *birth_rate;</span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="co">// now we need some helper vectors with the active and inactive nodes</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>    <span class="bu">std::</span>vector&lt;TreeNode*&gt; active;</span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="bu">std::</span>vector&lt;TreeNode*&gt; inactive;</span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-16"><a href="#cb11-16"></a>    <span class="co">// we also start our simulation with the root node</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>    <span class="co">// this means that we create the root node and the two children of it</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>    TreeNode *root = <span class="kw">new</span> TreeNode();</span>
<span id="cb11-19"><a href="#cb11-19"></a>    TreeNode *left = <span class="kw">new</span> TreeNode();</span>
<span id="cb11-20"><a href="#cb11-20"></a>    left-&gt;setParent( root );</span>
<span id="cb11-21"><a href="#cb11-21"></a>    root-&gt;setLeftChild( left );</span>
<span id="cb11-22"><a href="#cb11-22"></a>    TreeNode *right = <span class="kw">new</span> TreeNode();</span>
<span id="cb11-23"><a href="#cb11-23"></a>    right-&gt;setParent( root );</span>
<span id="cb11-24"><a href="#cb11-24"></a>    root-&gt;setRightChild( right );</span>
<span id="cb11-25"><a href="#cb11-25"></a></span>
<span id="cb11-26"><a href="#cb11-26"></a>    <span class="co">// now we also know that the age of the root was the age for the simulation</span></span>
<span id="cb11-27"><a href="#cb11-27"></a>    root-&gt;setAge( age );</span>
<span id="cb11-28"><a href="#cb11-28"></a></span>
<span id="cb11-29"><a href="#cb11-29"></a>    <span class="co">// add the two children of the root to the active list and the root to the inactive list</span></span>
<span id="cb11-30"><a href="#cb11-30"></a>    active.push_back(left);</span>
<span id="cb11-31"><a href="#cb11-31"></a>    active.push_back(right);</span>
<span id="cb11-32"><a href="#cb11-32"></a>    inactive.push_back(root);</span>
<span id="cb11-33"><a href="#cb11-33"></a></span>
<span id="cb11-34"><a href="#cb11-34"></a>    <span class="co">// now we simulate until we reached the present time (a time of 0)</span></span>
<span id="cb11-35"><a href="#cb11-35"></a>    <span class="co">// so we initialize the current time variable with the age of the tree</span></span>
<span id="cb11-36"><a href="#cb11-36"></a>    <span class="dt">double</span> current_time = age;</span>
<span id="cb11-37"><a href="#cb11-37"></a>    <span class="cf">while</span> ( current_time &gt; <span class="fl">0.0</span> )</span>
<span id="cb11-38"><a href="#cb11-38"></a>    {</span>
<span id="cb11-39"><a href="#cb11-39"></a>        <span class="co">// randomly draw a new speciation event</span></span>
<span id="cb11-40"><a href="#cb11-40"></a>        <span class="dt">double</span> rate = l*active.size();</span>
<span id="cb11-41"><a href="#cb11-41"></a>        <span class="dt">double</span> u = rng-&gt;uniform01();</span>
<span id="cb11-42"><a href="#cb11-42"></a>        <span class="dt">double</span> next_time = current_time + (<span class="fl">1.0</span>/rate) * <span class="bu">std::</span>log(u);</span>
<span id="cb11-43"><a href="#cb11-43"></a></span>
<span id="cb11-44"><a href="#cb11-44"></a>        <span class="co">// make sure that the next speciation time was not in the future</span></span>
<span id="cb11-45"><a href="#cb11-45"></a>        <span class="cf">if</span> ( next_time &lt; <span class="dv">0</span> )</span>
<span id="cb11-46"><a href="#cb11-46"></a>        {</span>
<span id="cb11-47"><a href="#cb11-47"></a>            <span class="cf">break</span>;</span>
<span id="cb11-48"><a href="#cb11-48"></a>        }</span>
<span id="cb11-49"><a href="#cb11-49"></a></span>
<span id="cb11-50"><a href="#cb11-50"></a>        <span class="co">// randomly pick a node that speciated</span></span>
<span id="cb11-51"><a href="#cb11-51"></a>        <span class="dt">size_t</span> index = rng-&gt;uniform01() * active.size();</span>
<span id="cb11-52"><a href="#cb11-52"></a>        TreeNode *node = active[index];</span>
<span id="cb11-53"><a href="#cb11-53"></a></span>
<span id="cb11-54"><a href="#cb11-54"></a>        <span class="co">// set the age of the speciation event</span></span>
<span id="cb11-55"><a href="#cb11-55"></a>        node-&gt;setAge( next_time );</span>
<span id="cb11-56"><a href="#cb11-56"></a></span>
<span id="cb11-57"><a href="#cb11-57"></a>        <span class="co">// add new descendants to the node</span></span>
<span id="cb11-58"><a href="#cb11-58"></a>        TreeNode *left = <span class="kw">new</span> TreeNode();</span>
<span id="cb11-59"><a href="#cb11-59"></a>        left-&gt;setParent( node );</span>
<span id="cb11-60"><a href="#cb11-60"></a>        node-&gt;setLeftChild( left );</span>
<span id="cb11-61"><a href="#cb11-61"></a>        TreeNode *right = <span class="kw">new</span> TreeNode();</span>
<span id="cb11-62"><a href="#cb11-62"></a>        right-&gt;setParent( node );</span>
<span id="cb11-63"><a href="#cb11-63"></a>        node-&gt;setRightChild( right );</span>
<span id="cb11-64"><a href="#cb11-64"></a></span>
<span id="cb11-65"><a href="#cb11-65"></a></span>
<span id="cb11-66"><a href="#cb11-66"></a>        <span class="co">// remove the current node and add it&#39;s two children to our active list</span></span>
<span id="cb11-67"><a href="#cb11-67"></a>        active.erase( active.begin() + index );</span>
<span id="cb11-68"><a href="#cb11-68"></a>        active.push_back( left );</span>
<span id="cb11-69"><a href="#cb11-69"></a>        active.push_back( right );</span>
<span id="cb11-70"><a href="#cb11-70"></a></span>
<span id="cb11-71"><a href="#cb11-71"></a>        <span class="co">// for later use, store the current node</span></span>
<span id="cb11-72"><a href="#cb11-72"></a>        inactive.push_back( node );</span>
<span id="cb11-73"><a href="#cb11-73"></a></span>
<span id="cb11-74"><a href="#cb11-74"></a>        <span class="co">// update the current time with the time of the next birth event</span></span>
<span id="cb11-75"><a href="#cb11-75"></a>        current_time = next_time;</span>
<span id="cb11-76"><a href="#cb11-76"></a></span>
<span id="cb11-77"><a href="#cb11-77"></a>    } <span class="co">// end while loop until the end of time</span></span>
<span id="cb11-78"><a href="#cb11-78"></a></span>
<span id="cb11-79"><a href="#cb11-79"></a>    <span class="co">// get how many tips we had at the end of the simulation</span></span>
<span id="cb11-80"><a href="#cb11-80"></a>    <span class="dt">size_t</span> num_taxa = active.size();</span>
<span id="cb11-81"><a href="#cb11-81"></a></span>
<span id="cb11-82"><a href="#cb11-82"></a>    <span class="co">// set the indices of the simulated</span></span>
<span id="cb11-83"><a href="#cb11-83"></a>    <span class="cf">for</span> ( <span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;inactive.size(); i++ )</span>
<span id="cb11-84"><a href="#cb11-84"></a>    {</span>
<span id="cb11-85"><a href="#cb11-85"></a>        TreeNode *node = inactive[i];</span>
<span id="cb11-86"><a href="#cb11-86"></a>        node-&gt;setIndex( <span class="dv">2</span>*num_taxa-<span class="dv">2</span>-i );</span>
<span id="cb11-87"><a href="#cb11-87"></a>    }</span>
<span id="cb11-88"><a href="#cb11-88"></a></span>
<span id="cb11-89"><a href="#cb11-89"></a>    <span class="co">// now also create some dummy tip names</span></span>
<span id="cb11-90"><a href="#cb11-90"></a>    <span class="cf">for</span> ( <span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;num_taxa; i++ )</span>
<span id="cb11-91"><a href="#cb11-91"></a>    {</span>
<span id="cb11-92"><a href="#cb11-92"></a></span>
<span id="cb11-93"><a href="#cb11-93"></a>        <span class="co">// randomly pick a node</span></span>
<span id="cb11-94"><a href="#cb11-94"></a>        <span class="dt">size_t</span> index = rng-&gt;uniform01() * active.size();</span>
<span id="cb11-95"><a href="#cb11-95"></a>        TreeNode *node = active[index];</span>
<span id="cb11-96"><a href="#cb11-96"></a>        <span class="co">// don&#39;t forget to erase it from our list</span></span>
<span id="cb11-97"><a href="#cb11-97"></a>        active.erase( active.begin() + index );</span>
<span id="cb11-98"><a href="#cb11-98"></a></span>
<span id="cb11-99"><a href="#cb11-99"></a>        <span class="co">// set the index of this tip</span></span>
<span id="cb11-100"><a href="#cb11-100"></a>        node-&gt;setIndex( i );</span>
<span id="cb11-101"><a href="#cb11-101"></a></span>
<span id="cb11-102"><a href="#cb11-102"></a>        <span class="co">// and create an arbitrary name for it</span></span>
<span id="cb11-103"><a href="#cb11-103"></a>        node-&gt;setName( <span class="st">&quot;Tip &quot;</span> + <span class="bu">std::</span>to_string(i) );</span>
<span id="cb11-104"><a href="#cb11-104"></a>    }</span>
<span id="cb11-105"><a href="#cb11-105"></a></span>
<span id="cb11-106"><a href="#cb11-106"></a>    <span class="co">// finally, we create our tree object by passing in the root node</span></span>
<span id="cb11-107"><a href="#cb11-107"></a>    Tree *t = <span class="kw">new</span> Tree( root );</span>
<span id="cb11-108"><a href="#cb11-108"></a></span>
<span id="cb11-109"><a href="#cb11-109"></a>    <span class="co">// and return the new tree</span></span>
<span id="cb11-110"><a href="#cb11-110"></a>    <span class="cf">return</span> t;</span>
<span id="cb11-111"><a href="#cb11-111"></a>}</span></code></pre></div>
<p>This it it. You have now written a simulator for a pure birth process!</p>
<h2 id="section-4.4-putting-it-together">Section 4.4: Putting it together</h2>
<p>In your <strong>main.cpp</strong> file, add the following lines:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a>RandomNumberGenerator *rng = <span class="kw">new</span> RandomNumberGenerator();</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">// simulate a starting tree</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="dt">double</span> *birth_rate = <span class="kw">new</span> <span class="dt">double</span>(<span class="fl">1.0</span>);</span>
<span id="cb12-5"><a href="#cb12-5"></a>PureBirthProcess *tree_prior = <span class="kw">new</span> PureBirthProcess( birth_rate );</span>
<span id="cb12-6"><a href="#cb12-6"></a>Tree *my_tree = tree_prior-&gt;rv(rng, <span class="dv">10</span>);</span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="bu">std::</span>cout &lt;&lt; my_tree-&gt;getNewickRepresentation() &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre></div>
<p>Don’t forget to also include the new classes that we just wrote today. Thus, add the two include statements at the beginning of the <strong>main.cpp</strong> file.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&quot;PureBirthProcess.h&quot;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="pp">#include </span><span class="im">&quot;RandomNumberGenerator.h&quot;</span></span></code></pre></div>
<p>Also, make sure to update the <strong>Makefile</strong> to include all files:</p>
<pre><code>SRC       = Alignment.cpp AlignmentReader.cpp TreeNode.cpp Tree.cpp NewickTreeReader.cpp RandomNumberGenerator.cpp PureBirthProcess.cpp main.cpp
OBJECTS   = Alignment.o AlignmentReader.o TreeNode.o Tree.o NewickTreeReader.o RandomNumberGenerator.o PureBirthProcess.o main.o</code></pre>
<p>Now compile and run your <em>BabyBayes</em>. How do the trees look when you simulate them? When you run <em>BabyBayes</em> again, do you get the same trees?</p>
<h2 id="section-4.5-exercises">Section 4.5: Exercises</h2>
<h3 id="subsection-4.5.1-how-random-are-the-random-numbers">Subsection 4.5.1: How random are the random numbers</h3>
<p>Write a new <strong>main.cpp</strong> and simulate 10,000 random <em>uniform01</em>. Write each number in a single line of a file. Then, create a histogram in <strong>R</strong> from these random numbers. Does this histogram show a uniform distribution?</p>
<h3 id="subsection-4.5.2-implement-another-random-number-generator">Subsection 4.5.2: Implement another random number generator</h3>
<p>There are more complex random number generators than the one we used. Let us play around with another one, a version of the Marsaglia Multi-Carry. You need to change your random number generator to use two seeds: <em>seed1</em> and <em>seed2</em>. You can initialize both seeds with</p>
<pre><code>unsigned int x = (unsigned int)( time( 0 ) );
seed1 = x &amp; 0xFFFF;
seed2 = x &gt;&gt; 16;</code></pre>
<p>Then, change the code of the <em>uniform01</em> function as follows.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">/**</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co"> * This function generates a uniformly-distributed random variable on the interval [0,1).</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co"> * It is a version of the Marsaglia Multi-Carry.</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co"> *</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co"> * Taken from:</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co"> *   Mathlib : A C Library of Special Functions</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co"> *   Copyright (C) 2000, 2003  The R Development Core Team</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="co"> *</span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="co"> * This random generator has a period of 2^60, which ensures it has the maximum</span></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="co"> * period of 2^32 for unsigned ints (32 bit ints).</span></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="co"> *</span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="co"> * </span><span class="an">@return</span><span class="co">                  Returns a uniformly-distributed random variable on the interval [0,1).</span></span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="co"> *</span></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="co"> * </span><span class="an">@see</span><span class="co"> http://stat.fsu.edu/~geo/diehard.html</span></span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="co"> */</span></span>
<span id="cb16-16"><a href="#cb16-16"></a><span class="dt">double</span> RandomNumberGenerator::uniform01(<span class="dt">void</span>)</span>
<span id="cb16-17"><a href="#cb16-17"></a>{</span>
<span id="cb16-18"><a href="#cb16-18"></a></span>
<span id="cb16-19"><a href="#cb16-19"></a>    <span class="co">// Returns a pseudo-random number between 0 and 1.</span></span>
<span id="cb16-20"><a href="#cb16-20"></a>    seed1 = <span class="dv">36969</span> * (seed1 &amp; <span class="bn">0177777</span>) + (seed1 &gt;&gt; <span class="dv">16</span>);</span>
<span id="cb16-21"><a href="#cb16-21"></a>    seed2 = <span class="dv">18000</span> * (seed2 &amp; <span class="bn">0177777</span>) + (seed2 &gt;&gt; <span class="dv">16</span>);</span>
<span id="cb16-22"><a href="#cb16-22"></a>    <span class="cf">return</span> (((seed1 &lt;&lt; <span class="dv">16</span>)^(seed2 &amp; <span class="bn">0177777</span>)) * <span class="fl">2.328306435996595e-10</span>) +  <span class="fl">2.328306437080797e-10</span> ;</span>
<span id="cb16-23"><a href="#cb16-23"></a>}</span></code></pre></div>
<p>Create 10,000 or 100,000 draws from this random number generator. Which one looks more uniform?</p>
<h3 id="subsection-4.5.3-implement-a-birth-death-process">Subsection 4.5.3: Implement a birth-death process</h3>
<p>We all know that extinction events happen. So we should try to make our models as realistic as possible, which means we should include death events into our tree prior and simulator. There are two parts for this. First, you need to adapt the simulation routine. Remember that the time between speciation <em>or</em> extinction events is exponentially distributed with parameter <span class="math inline">\(\lambda + \mu\)</span>. When an event occurs, it is a speciation with probability <span class="math inline">\(\frac{\lambda}{\lambda + \mu}\)</span> or an extinction with probability <span class="math inline">\(\frac{\mu}{\lambda + \mu}\)</span>. When an speciation event occurs, you can proceed as before. When an extinction event occurs, you should simply place the affected node into the inactive list and set the age for the node.</p>
<p>You should make sure that the process does not go extinct in your simulation. So the <em>while</em> loop should stop if there are no active lineages left; everyone went extinct. It might be fruitful to prune of all extinct lineages, but this should be an extra exercise.</p>
<p>Second, you also need to adapt the probability compution. We have derived for you the probability of the waiting time under the birth-death process: <span class="math inline">\(D(t) = \frac{4 e^{-(\lambda - \mu) t}}{(1 + \frac{\lambda + \mu}{\lambda - \mu} + e^{-(\lambda - \mu)t}(1 - \frac{\lambda + \mu}{\lambda - \mu}))^2}\)</span> To use this equation along a branch with begin age <span class="math inline">\(t_b\)</span> and end age <span class="math inline">\(t_e\)</span> where <span class="math inline">\(t_b &gt; t_e\)</span>, you need to compute <span class="math inline">\(\frac{D(t_b)}{D_e}\)</span>. The rest can remain the same!</p>
<p>Simulate and plot some trees under a birth-death process!</p>
<div>
<h2 id="references">References</h2>
</div>

<div id="refs" class="references" role="doc-bibliography">
<div id="ref-park88">
<p>Park, S. K., and K. W. Miller. 1988. Random number generators: Good ones are hard to find. Communications of the ACM 31:1192–1201.</p>
</div>
</div>
</body>
</html>
