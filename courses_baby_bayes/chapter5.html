---
layout: chapter
title: The Substitution Rate Matrix
output:
  html_document:
    toc: true
    toc_float: true
pdf: true
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The Substitution Rate Matrix</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">The Substitution Rate Matrix</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter-5-rate-matrix-and-calculating-transition-probabilities">Chapter 5: Rate matrix and calculating transition probabilities</a><ul>
<li><a href="#section-5.1-background-on-substitution-rate-matrices">Section 5.1: Background on Substitution Rate Matrices</a><ul>
<li><a href="#subsection-5.1.1.-transition-probabilities">Subsection 5.1.1.: Transition probabilities</a></li>
<li><a href="#subsection-5.1.2-stationary-distribution">Subsection 5.1.2: Stationary distribution</a></li>
</ul></li>
<li><a href="#section-5.2-definition-of-the-jukes-cantor-rate-matrix-class">Section 5.2: Definition of the Jukes-Cantor Rate Matrix class</a></li>
<li><a href="#section-5.3-implementation-of-the-jukes-cantor-rate-matrix-class">Section 5.3: Implementation of the Jukes-Cantor Rate Matrix class</a></li>
<li><a href="#section-5.4-testing-your-rate-matrix">Section 5.4: Testing your rate matrix</a></li>
<li><a href="#section-5.5-simulating-dna-sequences">Section 5.5: Simulating DNA Sequences</a></li>
<li><a href="#section-5.5.1-definition-of-the-phyloctmc-class">Section 5.5.1: Definition of the PhyloCTMC class</a></li>
<li><a href="#section-5.5.2-implementation-of-the-phyloctmc-class">Section 5.5.2: Implementation of the PhyloCTMC class</a><ul>
<li><a href="#subsection-5.5.3-testing-your-alignment-simulator">Subsection 5.5.3: Testing your Alignment Simulator</a></li>
</ul></li>
<li><a href="#section-5.6-exercises">Section 5.6: Exercises</a><ul>
<li><a href="#subsection-5.6.1-the-felsenstein-1981-model">Subsection 5.6.1: The Felsenstein 1981 Model</a></li>
<li><a href="#subsection-5.6.2-the-hasegawa-kishino-yano-model">Subsection 5.6.2: The Hasegawa-Kishino-Yano Model</a></li>
</ul></li>
<li><a href="#subsection-5.6.3-using-substitution-rates-to-simulate-alignments">Subsection 5.6.3: Using Substitution Rates to Simulate Alignments</a></li>
</ul></li>
</ul>
</nav>
<div>
<p><a href="{{site.baseurl}}/pdf/chapter5.pdf">pdf version</a></p>
</div>
<h1 id="chapter-5-rate-matrix-and-calculating-transition-probabilities">Chapter 5: Rate matrix and calculating transition probabilities</h1>
<h2 id="section-5.1-background-on-substitution-rate-matrices">Section 5.1: Background on Substitution Rate Matrices</h2>
<p>All model-based methods of phylogenetic inference, including maximum likelihood and Bayesian estimation of phylogeny, currently assume that character change occurs according to a continuous-time Markov chain. At the heart of any continuous-time Markov chain is a matrix of rates, specifying the rate of change from one state to another. For example, the instantaneous rate of change under the model described by [hereafter called the HKY85 model]<span class="citation" data-cites="hasegawa85">(<a href="#ref-hasegawa85" role="doc-biblioref">1985</a>)</span> is <span class="math display">\[
{\mathbf Q} = \{q_{ij}\} = \left( \begin{array}{cccc}
-               &amp;  \pi_C &amp; \kappa \pi_G &amp; \pi_T \\
\pi_A &amp; -               &amp; \pi_G &amp; \kappa \pi_T \\
\kappa \pi_A &amp; \pi_C &amp; -               &amp; \pi_T \\
\pi_A &amp; \kappa \pi_C &amp; \pi_G &amp; -               \\
\end{array} \right) \mu
\]</span> This matrix specifies the rate of change from one nucleotide to another; the rows and columns of the matrix are ordered <span class="math inline">\(A, C, G, T\)</span>, so that the rate of change from <span class="math inline">\(C \rightarrow G\)</span> is <span class="math inline">\(q_{CG} = \pi_G\)</span>. Similarly, the rates of change between <span class="math inline">\(C \rightarrow T\)</span>, <span class="math inline">\(G \rightarrow A\)</span>, and <span class="math inline">\(T \rightarrow C\)</span>, are <span class="math inline">\(q_{CT} = \kappa \pi_T\)</span>, <span class="math inline">\(q_{GA} = \kappa \pi_A\)</span>, and <span class="math inline">\(q_{TG} = \pi_G\)</span>, respectively. The diagonals of the rate matrix, denoted with the dashes, are specified such that each row sums to zero. Finally, the rate matrix is rescaled such that the mean rate of substitution is one. This can be accomplished by setting <span class="math inline">\(\mu = -1 / \sum_{i\in \{A,C,G,T\}} \pi_i q_{ii}\)</span>. This rescaling of the rate matrix such that the mean rate is one allows the branch lengths on the phylogenetic tree to be interpreted as expected number of nucleotide substitutions per site.</p>
<p>We will make a few important points about the rate matrix. First, the rate matrix may have free parameters. For example, the HKY85 model has the parameters <span class="math inline">\(\kappa\)</span>, <span class="math inline">\(\pi_A\)</span>, <span class="math inline">\(\pi_C\)</span>, <span class="math inline">\(\pi_G\)</span>, and <span class="math inline">\(\pi_T\)</span>. The parameter <span class="math inline">\(\kappa\)</span> is the transition/transversion rate bias; when <span class="math inline">\(\kappa = 1\)</span> transitions occur at the same rate as transversions. Typically, the transition/transversion rate ratio, estimated using maximum likelihood or Bayesian inference, is greater than one; transitions occur at a higher rate than transversions. The other parameters — <span class="math inline">\(\pi_A\)</span>, <span class="math inline">\(\pi_C\)</span>, <span class="math inline">\(\pi_G\)</span>, and <span class="math inline">\(\pi_T\)</span> — are the base frequencies, and have a biological interpretation as the frequency of the different nucleotides and are also, incidentally, the stationary probabilities of the process (more on stationary probabilities later). Second, the rate matrix, <span class="math inline">\({\mathbf Q}\)</span>, can be used to calculate the transition probabilities and the stationary distribution of the substitution process. The transition probabilities and stationary distribution play a key role in calculating the likelihood, and we will spend more time here developing an intuitive understanding of these concepts.</p>
<h3 id="subsection-5.1.1.-transition-probabilities">Subsection 5.1.1.: Transition probabilities</h3>
<p>Let us consider a specific example of a rate matrix, with all of the parameters of the model taking specific values. For example, if we use the HKY85 model and fix the parameters to <span class="math inline">\(\kappa = 5\)</span>, <span class="math inline">\(\pi_A = 0.4\)</span>, <span class="math inline">\(\pi_C = 0.3\)</span>, <span class="math inline">\(\pi_G = 0.2\)</span>, and <span class="math inline">\(\pi_T = 0.1\)</span>, we get the following matrix of instantaneous rates <span class="math display">\[
{\mathbf Q} = \{q_{ij}\} = \left( \begin{array}{rrrr}
-0.886 &amp;  0.190 &amp;  0.633 &amp;  0.063 \\
 0.253 &amp; -0.696 &amp;  0.127 &amp;  0.316 \\
 1.266 &amp;  0.190 &amp; -1.519 &amp;  0.063 \\
 0.253 &amp;  0.949 &amp;  0.127 &amp; -1.329 \\
\end{array} \right)
\]</span> Note that these numbers are not special in any particular way. That is to say, they are not based upon any observations from a real data set, but are rather arbitrarily picked to illustrate a point. The point is that one can interpret the rate matrix in the physical sense of specifying how changes occur on a phylogenetic tree. Consider the very simple case of a single branch on a phylogenetic tree. Let’s assume that the branch is <span class="math inline">\(v=0.5\)</span> in length and that the ancestor of the branch is the nucleotide <span class="math inline">\(G\)</span>. The situation we have is something like that shown in Figure a. How can we simulate the evolution of the site starting from the <span class="math inline">\(G\)</span> at the ancestor? The rate matrix tells us how to do this. First of all, because the current state of the process is <span class="math inline">\(G\)</span>, the only relevant row of the rate matrix is the third one: <span class="math display">\[
{\mathbf Q} = \{q_{ij}\} = \left( \begin{array}{cccc}
\cdot   &amp;   \cdot &amp;    \cdot &amp;  \cdot \\
\cdot   &amp;   \cdot &amp;    \cdot &amp;  \cdot \\
1.266 &amp;  0.190 &amp; -1.519 &amp;  0.063 \\
\cdot   &amp;   \cdot &amp;    \cdot &amp; \cdot \\
\end{array} \right)
\]</span> The overall rate of change away from nucleotide <span class="math inline">\(G\)</span> is <span class="math inline">\(q_{GA} + q_{GC} + q_{GT} = 1.266 + 0.190 + 0.063 = 1.519\)</span>. Equivalently, the rate of change away from nucleotide <span class="math inline">\(G\)</span> is simply <span class="math inline">\(-q_{GG} = 1.519\)</span>. In a continuous-time Markov model, the waiting time between substitutions is exponentially distributed. The exact shape of the exponential distribution is determined by its rate, which is the same as the rate of the corresponding process in the <span class="math inline">\({\mathbf Q}\)</span> matrix. For instance, if we are in state <span class="math inline">\(G\)</span>, we wait an exponentially distributed amount of time with rate 1.519 until the next substitution occurs. One can easily construct exponential random variables from uniform random variables using the equation</p>

<p><span class="math display">\[
t = -\frac{1}{\lambda} \log_e(u)
\]</span> where <span class="math inline">\(\lambda\)</span> is the rate and <span class="math inline">\(u\)</span> is a uniform(0,1) random number. For example, my calculator has a uniform(0,1) random number generator. The first number it generated is <span class="math inline">\(u = 0.794\)</span>. This means that the next time at which a substitution occurs is 0.152 up from the root of the tree (using <span class="math inline">\(\lambda = 1.519\)</span>; Figure b). The rate matrix also specifies the probabilities of a change from <span class="math inline">\(G\)</span> to the nucleotides <span class="math inline">\(A\)</span>, <span class="math inline">\(C\)</span>, and <span class="math inline">\(T\)</span>.<br />
These probabilities are <span class="math display">\[
\begin{array}{ccc}
G \rightarrow A: \frac{1.266}{1.519}=0.833, &amp;  G \rightarrow C: \frac{0.190}{1.519}=0.125, &amp; G \rightarrow T: \frac{0.063}{1.519}=0.042 \\
\end{array}
\]</span> To determine what nucleotide the process changes to we would generate another uniform(0,1) random number (again called <span class="math inline">\(u\)</span>). If <span class="math inline">\(u\)</span> is between 0 and 0.833, we will say that we had a change from <span class="math inline">\(G\)</span> to <span class="math inline">\(A\)</span>. If the random number is between 0.833 and 0.958 we will say that we had a change from <span class="math inline">\(G\)</span> to <span class="math inline">\(C\)</span>. Finally, if the random number <span class="math inline">\(u\)</span> is between 0.958 and 1.000, we will say we had a change from <span class="math inline">\(G\)</span> to <span class="math inline">\(T\)</span>. The next number generated on our calculator was <span class="math inline">\(u = 0.102\)</span>, which means the change was from <span class="math inline">\(G\)</span> to <span class="math inline">\(A\)</span>. The process is now in a different state (the nucleotide <span class="math inline">\(A\)</span>) and the relevant row of the rate matrix is <span class="math display">\[
{\mathbf Q} = \{q_{ij}\} = \left( \begin{array}{cccc}
-0.886 &amp;  0.190 &amp;  0.633 &amp;  0.063 \\
\cdot &amp; \cdot &amp;  \cdot &amp;  \cdot \\
\cdot &amp;  \cdot &amp; \cdot &amp;  \cdot \\
\cdot &amp;  \cdot &amp;  \cdot &amp; \cdot \\
\end{array} \right)
\]</span> We wait an exponentially distributed amount of time with parameter <span class="math inline">\(\lambda = 0.886\)</span> until the next substitution occurs. When the substitution occurs, it is to a <span class="math inline">\(C\)</span>, <span class="math inline">\(G\)</span>, or <span class="math inline">\(T\)</span> with probabilities <span class="math inline">\(\frac{0.190}{0.886} = 0.214\)</span>, <span class="math inline">\(\frac{0.633}{0.886} = 0.714\)</span>, and <span class="math inline">\(\frac{0.063}{0.886} = 0.072\)</span>, respectively. This process of generating random and exponentially distributed times until the next substitution occurs and then determining (randomly) what nucleotide the change is to is repeated until the process exceeds the length of the branch. The state the process is in when it passes the end of the branch is recorded. In the example of Figure~, the process started in state <span class="math inline">\(G\)</span> and ended in state <span class="math inline">\(A\)</span>. (The next uniform random variable generated on our calculator was <span class="math inline">\(u = 0.371\)</span>, which means that the next substitution would occur 1.119 units above the substitution from <span class="math inline">\(G \rightarrow A\)</span>. The process is in the state <span class="math inline">\(A\)</span> when it passed the end of the branch.) The only non-random part of the entire procedure was the initial decision to start the process in state <span class="math inline">\(G\)</span>. All other aspects of the simulation used a uniform random number generator and our knowledge of the rate matrix to simulate a single realization of the HKY85 process of DNA substitution.</p>
This Monte Carlo procedure for simulating the HKY85 process of DNA substitution can be repeated. The following table summarizes the results of 100 simulations, each of which started with the nucleotide <span class="math inline">\(G\)</span>:

This table can be interpreted as a Monte Carlo approximation of the {} from nucleotide <span class="math inline">\(G\)</span> to nucleotide <span class="math inline">\(i \in (A,C,G,T)\)</span>. Specifically, the Monte Carlo approximations are <span class="math inline">\(p_{GA}(0.5) \approx 0.27\)</span>, <span class="math inline">\(p_{GC}(0.5) \approx 0.10\)</span>, <span class="math inline">\(p_{GG}(0.5) \approx 0.59\)</span>, and <span class="math inline">\(p_{GT}(0.5) \approx 0.04\)</span>. These approximate probabilities are all conditioned on the starting nucleotide being <span class="math inline">\(G\)</span> and the branch length being <span class="math inline">\(v = 0.5\)</span>. We performed additional simulations in which the starting nucleotide was <span class="math inline">\(A\)</span>, <span class="math inline">\(C\)</span>, or <span class="math inline">\(T\)</span>. Together with the earlier Monte Carlo simulation that started with the nucleotide <span class="math inline">\(G\)</span>, these additional simulations allow us to fill out the following table with the approximate transition probabilities:

<p>Clearly, these numbers are only crude approximations to the true transition probabilities; after all, each row in the table is based on only 100 Monte Carlo simulations. However, they do illustrate the meaning of the transition probabilities; the transition probability, <span class="math inline">\(p_{ij}(v)\)</span>, is the probability that the substitution process ends in nucleotide <span class="math inline">\(j\)</span> conditioned on it starting in nucleotide <span class="math inline">\(i\)</span> after an evolutionary amount of time <span class="math inline">\(v\)</span>. The table of approximate transition probabilities, above, can be interpreted as a matrix of probabilities, usually denoted <span class="math inline">\({\mathbf P}(v)\)</span>. Fortunately, we do not need to rely on Monte Carlo simulation to approximate the transition probability matrix. Instead, we can calculate the transition probability matrix exactly using matrix exponentiation: <span class="math display">\[
{\mathbf P}(v) = e^{Qv}
\]</span> For the case we have been simulating, the exact transition probabilities (to four decimal places) are <span class="math display">\[
{\mathbf P}(0.5) = \{p_{ij}(0.5)\} = \left( \begin{array}{rrrr}
0.7079 &amp; 0.0813 &amp; 0.1835 &amp; 0.0271 \\
0.1085 &amp; 0.7377 &amp; 0.0542 &amp; 0.0995 \\
0.3670 &amp; 0.0813 &amp; 0.5244 &amp; 0.0271 \\
0.1085 &amp; 0.2985 &amp; 0.0542 &amp; 0.5387 \\
\end{array} \right)
\]</span> The transition probability matrix accounts for all the possible ways the process could end up in nucleotide <span class="math inline">\(j\)</span> after starting in nucleotide <span class="math inline">\(i\)</span>. In fact, each of the infinite possibilities is weighted by its probability under the substitution model.</p>
<h3 id="subsection-5.1.2-stationary-distribution">Subsection 5.1.2: Stationary distribution</h3>
<p>The transition probabilities provide the probability of ending in a particular nucleotide after some specific amount of time (or opportunity for substitution, <span class="math inline">\(v\)</span>). These transition probabilities are conditioned on starting in a particular nucleotide. What do the transition probability matrices look like as <span class="math inline">\(v\)</span> increases? The following transition probability matrices show the effect of increasing branch length: <span class="math display">\[
\begin{array}{cc}
{\mathbf P}(0.00) = \left( \begin{array}{rrrr}
1.000 &amp; 0.000 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 1.000 &amp; 0.000 &amp; 0.000 \\
0.000 &amp; 0.000 &amp; 1.000 &amp; 0.000 \\
0.000 &amp; 0.000 &amp; 0.000 &amp; 1.000 \\
\end{array} \right)
 &amp;
{\mathbf P}(0.01) = \left( \begin{array}{rrrr}
0.991 &amp; 0.002 &amp; 0.006 &amp; 0.001 \\
0.003 &amp; 0.993 &amp; 0.001 &amp; 0.003 \\
0.013 &amp; 0.002 &amp; 0.985 &amp; 0.001 \\
0.003 &amp; 0.009 &amp; 0.001 &amp; 0.987 \\
\end{array} \right)
\end{array}
\]</span> <span class="math display">\[
\begin{array}{cc}
{\mathbf P}(0.10) = \left( \begin{array}{rrrr}
0.919 &amp; 0.018 &amp; 0.056 &amp; 0.006 \\
0.024 &amp; 0.934 &amp; 0.012 &amp; 0.029 \\
0.113 &amp; 0.018 &amp; 0.863 &amp; 0.006 \\
0.025 &amp; 0.086 &amp; 0.012 &amp; 0.877 \\
\end{array} \right)
 &amp;
{\mathbf P}(0.50) = \left( \begin{array}{rrrr}
0.708 &amp; 0.081 &amp; 0.184 &amp; 0.027 \\
0.106 &amp; 0.738 &amp; 0.054 &amp; 0.100 \\
0.367 &amp; 0.081 &amp; 0.524 &amp; 0.027 \\
0.109 &amp; 0.299 &amp; 0.054 &amp; 0.539 \\
\end{array} \right)
\end{array}
\]</span> <span class="math display">\[
\begin{array}{cc}
{\mathbf P}(1.00) = \left( \begin{array}{rrrr}
0.580 &amp; 0.141 &amp; 0.232 &amp; 0.047 \\
0.188 &amp; 0.587 &amp; 0.094 &amp; 0.131 \\
0.464 &amp; 0.141 &amp; 0.348 &amp; 0.047 \\
0.188 &amp; 0.394 &amp; 0.094 &amp; 0.324 \\
\end{array} \right)
 &amp;
{\mathbf P}(5.00) = \left( \begin{array}{rrrr}
0.411 &amp; 0.287 &amp; 0.206 &amp; 0.096 \\
0.383 &amp; 0.319 &amp; 0.192 &amp; 0.106 \\
0.411 &amp; 0.287 &amp; 0.206 &amp; 0.096 \\
0.383 &amp; 0.319 &amp; 0.192 &amp; 0.107 \\
\end{array} \right)
\end{array}
\]</span> <span class="math display">\[
\begin{array}{cc}
{\mathbf P}(10.0) = \left( \begin{array}{rrrr}
0.401 &amp; 0.299 &amp; 0.200 &amp; 0.099 \\
0.399 &amp; 0.301 &amp; 0.199 &amp; 0.100 \\
0.401 &amp; 0.299 &amp; 0.200 &amp; 0.099 \\
0.399 &amp; 0.301 &amp; 0.199 &amp; 0.100 \\
\end{array} \right)
 &amp;
{\mathbf P}(100) = \left( \begin{array}{rrrr}
0.400 &amp; 0.300 &amp; 0.200 &amp; 0.100 \\
0.400 &amp; 0.300 &amp; 0.200 &amp; 0.100 \\
0.400 &amp; 0.300 &amp; 0.200 &amp; 0.100 \\
0.400 &amp; 0.300 &amp; 0.200 &amp; 0.100 \\
\end{array} \right)
\\
\end{array}
\]</span> (Each matrix was calculated under the HKY85 model with <span class="math inline">\(\kappa = 5\)</span>, <span class="math inline">\(\pi_A = 0.4\)</span>, <span class="math inline">\(\pi_C = 0.3\)</span>, <span class="math inline">\(\pi_G = 0.2\)</span>, and <span class="math inline">\(\pi_T = 0.1\)</span>.) Note that as the length of a branch, <span class="math inline">\(v\)</span>, increases, the probability of ending up in a particular nucleotide converges to a single number, regardless of the starting state. For example, the probability of ending up in <span class="math inline">\(C\)</span> is about 0.300 when the branch length is <span class="math inline">\(v=100\)</span>. This is true regardless of whether the process starts in <span class="math inline">\(A\)</span>, <span class="math inline">\(C\)</span>, <span class="math inline">\(G\)</span>, or <span class="math inline">\(T\)</span>. The substitution process has in a sense ‘forgotten’ its starting state.</p>
<p>The stationary distribution is the probability of observing a particular state when the branch length increases without limit (<span class="math inline">\(v \rightarrow \infty\)</span>). The stationary probabilities of the four nucleotides are <span class="math inline">\(\pi_A = 0.4\)</span>, <span class="math inline">\(\pi_C = 0.3\)</span>, <span class="math inline">\(\pi_G = 0.2\)</span>, and <span class="math inline">\(\pi_T = 0.1\)</span> for the example discussed above. The models typically used in phylogenetic analyses have the stationary probabilities built into the rate matrix, <span class="math inline">\({\mathbf Q}\)</span>. You will notice that the rate matrix for the HKY85 model has parameters <span class="math inline">\(\pi_A\)</span>, <span class="math inline">\(\pi_C\)</span>, <span class="math inline">\(\pi_G\)</span>, and <span class="math inline">\(\pi_T\)</span>, and that the stationary frequencies of the four nucleotides for our example match the input values for our simulations. Building the stationary frequency of the process into the rate matrix, while somewhat unusual, makes calculating the likelihood function easier. For one, specifying the stationary distribution saves the time of figuring out what the stationary distribution is (which involves solving the equation <span class="math inline">\(\pi {\mathbf Q} = {\mathbf 0}\)</span>, which simply says that, if we start with the nucleotide frequencies reflecting the stationary distribution, the process will have no effect on the nucleotide frequencies). For another, it allows one to more easily specify a time reversible substitution model. [A time reversible substitution model has the property that <span class="math inline">\(\pi_i q_{ij} = \pi_j q_{ji}\)</span> for all <span class="math inline">\(i, j \in (A,C,G,T)\)</span>, <span class="math inline">\(i \neq j\)</span>.] Practically speaking, time reversibility means that we can work with unrooted trees instead of rooted trees (assuming that the molecular clock is not enforced).</p>
<h2 id="section-5.2-definition-of-the-jukes-cantor-rate-matrix-class">Section 5.2: Definition of the Jukes-Cantor Rate Matrix class</h2>
<p>In todays class we will first start with the implementation of the Jukes-Cantor substitution model. The Jukes-Cantor substitution model has the rate matrix defined as <span class="math display">\[
{\mathbf Q} = \{q_{ij}\} = \left( \begin{array}{cccc}
  1 &amp; \frac{1}{3} &amp;  \frac{1}{3} &amp;  \frac{1}{3} \\
\frac{1}{3} &amp;  1  &amp;  \frac{1}{3} &amp;  \frac{1}{3} \\
\frac{1}{3} &amp;  \frac{1}{3} &amp;  1  &amp;  \frac{1}{3} \\
\frac{1}{3} &amp;  \frac{1}{3} &amp;  \frac{1}{3} &amp;  1  \\
\end{array} \right)
\]</span> You can see in the rate matrix that the rates of substitutions do not depend on the current state. They are all equal. In fact, the Jukes-Cantor substitution model has only one free parameter: the overall rate of evolution, which is confounded with the branch lengths and thus usually omitted. One nice feature of the Jukes-Cantor substitution model is that we can compute the transition probabilities fairly easy, as given by <span class="math display">\[
{\mathbf P}_{ij}(\nu) = \begin{cases}
{1\over4} + {3\over4}e^{-4\nu/3}  &amp; \mbox{ if } i = j   \\
{1\over4} - {1\over4}e^{-4\nu/3}  &amp; \mbox{ if } i \neq j
\end{cases}
\]</span> Let’s put this into C++ code.</p>
<p>Create a new file called <strong>RateMatrix_JC.h</strong> which defines the rate matrix class. There shouldn’t be much new in this class and you should be familiar with the syntax by now. The one main function provided by the class is the method <em>calculateTransitionProbabilities</em>, which compute the matrix of transition probabilities.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#ifndef RateMatrix_JC_h</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#define RateMatrix_JC_h</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">/**</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co"> * </span><span class="an">\class</span><span class="co"> </span><span class="cv">RateMatrix_JC</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"> *</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co"> * </span><span class="an">\brief</span><span class="co"> Represents the rate matrix class for the Jukes-Cantor (1969) model.</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co"> *</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co"> * This class provides the transition probability calculation using for the Jukes-Cantor (1969) rate matrix.</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co"> * The purpose is simply to calculate these transition probabilities for a given branch length.</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co"> * For the Jukes-Cantor rate matrix we know the analytical solution for the transition probabilities.</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co"> * The JC has no parameter but can be applied to any number of states.</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co"> * The resulting rate matrix is computed by:</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="co"> *</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="co"> *      |   -     1/3    1/3    1/3  |</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="co"> *      |                            |</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="co"> *      |  1/3     -     1/3    1/3  |</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="co"> * Q =  |                            |</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="co"> *      |  1/3    1/3     -     1/3  |</span></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="co"> *      |                            |</span></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="co"> *      |  1/3    1/3    1/3     -   |</span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="co"> *</span></span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="co"> *</span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="co"> * </span><span class="an">\author</span><span class="co"> Sebastian Höhna</span></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="co"> *</span></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="co"> */</span></span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="kw">class</span> RateMatrix_JC {</span>
<span id="cb1-31"><a href="#cb1-31"></a></span>
<span id="cb1-32"><a href="#cb1-32"></a><span class="kw">public</span>:</span>
<span id="cb1-33"><a href="#cb1-33"></a></span>
<span id="cb1-34"><a href="#cb1-34"></a>    RateMatrix_JC();</span>
<span id="cb1-35"><a href="#cb1-35"></a>    <span class="kw">virtual</span>                                        ~RateMatrix_JC();</span>
<span id="cb1-36"><a href="#cb1-36"></a></span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;               calculateTransitionProbabilities(<span class="dt">double</span> time, <span class="dt">double</span> rate) <span class="at">const</span>;       <span class="co">//!&lt; Calculate the transition matrix</span></span>
<span id="cb1-38"><a href="#cb1-38"></a></span>
<span id="cb1-39"><a href="#cb1-39"></a>};</span>
<span id="cb1-40"><a href="#cb1-40"></a></span>
<span id="cb1-41"><a href="#cb1-41"></a><span class="pp">#endif </span><span class="co">/* RateMatrix_JC_h */</span></span></code></pre></div>
<p>You can safely copy-and-paste the above code.</p>
<h2 id="section-5.3-implementation-of-the-jukes-cantor-rate-matrix-class">Section 5.3: Implementation of the Jukes-Cantor Rate Matrix class</h2>
<p>Now continue with the implementation of the Jukes-Cantor rate matrix class by actually implementing it. Create a new file called <strong>RateMatrix_JC.cpp</strong>. As usual, this file will contain our implementation.</p>
<p>First, we start with the necessary header files and libraries that we need to include. Here, this is only the definition of the the <em>RateMatrix_JC</em> and <em>cmath</em> for computing exponential numbers.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&quot;RateMatrix_JC.h&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span></code></pre></div>
<p>The next step is to add the default constructor of the class that doesn’t actually need to do anything.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">/**</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co"> * Constructor of the Jukes-Cantor Rate Matrix class.</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co"> *</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"> * There are no variables that need to be initialized.</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co"> *</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co"> */</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>RateMatrix_JC::RateMatrix_JC( <span class="dt">void</span> )</span>
<span id="cb3-8"><a href="#cb3-8"></a>{</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a>}</span></code></pre></div>
<p>Similarly, we add the destructor for completeness although there is no allocated memory to free.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">/**</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co"> * Destructor.</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co"> *</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co"> * Since we do not have any member variables, there is no memory to free here.</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co"> *</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co"> */</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>RateMatrix_JC::~RateMatrix_JC( <span class="dt">void</span> )</span>
<span id="cb4-8"><a href="#cb4-8"></a>{</span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a>}</span></code></pre></div>
<p>Now we get the juicy part: the implementation of the <em>calculateTransitionProbabilities</em> method. However, this method is not too complicated. We simply need to create a transition probability matrix, which we define as being of type <em>std::vector&lt;std::vector<double> &gt;</em>, that is, a vector of a vector of real numbers. Then, we compute the entries for each cell by either using <span class="math inline">\(1/4 - 1/4 * exp(-v*4/3)\)</span> for off diagonal entries and <span class="math inline">\(1/4 + 3/4 * exp(-v*4/3)\)</span> for entries along the diagonal.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">/**</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co"> * Calculate the transition probabilities.</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co"> *</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co"> * The transition probabilities are computed as</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co"> *  for off diagonals:      1/4 - 1/4 * exp(-v*4/3)</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co"> *  for diagonals:          1/4 + 3/4 * exp(-v*4/3)</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co"> * Where v = t * r</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co"> *</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">time</span><span class="co">            The branch time (t) for which to compute the transition probabilities (bl = t * r).</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">rate</span><span class="co">            The branch rate (r) for which to compute the transition probabilities (bl = t * r).</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co"> * </span><span class="an">@return</span><span class="co">                  The transition probability matrix.</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co"> */</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt; RateMatrix_JC::calculateTransitionProbabilities(<span class="dt">double</span> time, <span class="dt">double</span> rate) <span class="at">const</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>{</span>
<span id="cb5-15"><a href="#cb5-15"></a></span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="dt">size_t</span> num_states = <span class="dv">4</span>;</span>
<span id="cb5-17"><a href="#cb5-17"></a></span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt; P = <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt;(num_states, <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;(num_states, <span class="fl">0.0</span>));</span>
<span id="cb5-19"><a href="#cb5-19"></a></span>
<span id="cb5-20"><a href="#cb5-20"></a>    <span class="dt">double</span> v = rate * time;</span>
<span id="cb5-21"><a href="#cb5-21"></a></span>
<span id="cb5-22"><a href="#cb5-22"></a>    <span class="co">// calculate the transition probabilities</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>    <span class="dt">double</span> bf = <span class="fl">1.0</span> / num_states;</span>
<span id="cb5-24"><a href="#cb5-24"></a>    <span class="dt">double</span> one_minus_bf = <span class="fl">1.0</span> - bf;</span>
<span id="cb5-25"><a href="#cb5-25"></a>    <span class="dt">double</span> p_ii = bf + one_minus_bf * exp(-v/one_minus_bf);</span>
<span id="cb5-26"><a href="#cb5-26"></a>    <span class="dt">double</span> p_ij = bf - bf * exp(-v/one_minus_bf);</span>
<span id="cb5-27"><a href="#cb5-27"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;num_states; i++)</span>
<span id="cb5-28"><a href="#cb5-28"></a>    {</span>
<span id="cb5-29"><a href="#cb5-29"></a>        P[i][i] = p_ii;</span>
<span id="cb5-30"><a href="#cb5-30"></a>        <span class="cf">for</span> (<span class="dt">size_t</span> j=i+<span class="dv">1</span>; j&lt;num_states; j++)</span>
<span id="cb5-31"><a href="#cb5-31"></a>        {</span>
<span id="cb5-32"><a href="#cb5-32"></a>            P[i][j] = p_ij;</span>
<span id="cb5-33"><a href="#cb5-33"></a>            P[j][i] = p_ij;</span>
<span id="cb5-34"><a href="#cb5-34"></a>        }</span>
<span id="cb5-35"><a href="#cb5-35"></a></span>
<span id="cb5-36"><a href="#cb5-36"></a>    }</span>
<span id="cb5-37"><a href="#cb5-37"></a></span>
<span id="cb5-38"><a href="#cb5-38"></a>    <span class="cf">return</span> P;</span>
<span id="cb5-39"><a href="#cb5-39"></a>}</span></code></pre></div>
<p>This concludes our rate matrix class. That wasn’t too bad :) This could actually be sufficient for computing the phylogenetic likelihood function and this simple model. Let’s have a look at the transition probabilities before we proceed.</p>
<h2 id="section-5.4-testing-your-rate-matrix">Section 5.4: Testing your rate matrix</h2>
<p>In your <strong>main.cpp</strong> file, add the following lines:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">// create a transition rate matrix</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>RateMatrix_JC *my_rate_matrix = <span class="kw">new</span> RateMatrix_JC();</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt; P;</span>
<span id="cb6-4"><a href="#cb6-4"></a>P = my_rate_matrix-&gt;calculateTransitionProbabilities( <span class="fl">0.0</span>, <span class="fl">1.0</span> );</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="cf">for</span> (<span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">4</span>; i++)</span>
<span id="cb6-6"><a href="#cb6-6"></a>{</span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> j=<span class="dv">0</span>; j&lt;<span class="dv">4</span>; j++)</span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="bu">std::</span>cout &lt;&lt; P[i][j] &lt;&lt; <span class="st">&quot;  &quot;</span>;</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb6-10"><a href="#cb6-10"></a>}</span>
<span id="cb6-11"><a href="#cb6-11"></a>P = my_rate_matrix-&gt;calculateTransitionProbabilities( <span class="fl">1.0</span>, <span class="fl">1.0</span> );</span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="cf">for</span> (<span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">4</span>; i++)</span>
<span id="cb6-13"><a href="#cb6-13"></a>{</span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> j=<span class="dv">0</span>; j&lt;<span class="dv">4</span>; j++)</span>
<span id="cb6-15"><a href="#cb6-15"></a>        <span class="bu">std::</span>cout &lt;&lt; P[i][j] &lt;&lt; <span class="st">&quot;  &quot;</span>;</span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb6-17"><a href="#cb6-17"></a>}</span>
<span id="cb6-18"><a href="#cb6-18"></a>P = my_rate_matrix-&gt;calculateTransitionProbabilities( <span class="fl">10.0</span>, <span class="fl">1.0</span> );</span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="cf">for</span> (<span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;<span class="dv">4</span>; i++)</span>
<span id="cb6-20"><a href="#cb6-20"></a>{</span>
<span id="cb6-21"><a href="#cb6-21"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> j=<span class="dv">0</span>; j&lt;<span class="dv">4</span>; j++)</span>
<span id="cb6-22"><a href="#cb6-22"></a>        <span class="bu">std::</span>cout &lt;&lt; P[i][j] &lt;&lt; <span class="st">&quot;  &quot;</span>;</span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb6-24"><a href="#cb6-24"></a>}</span></code></pre></div>
<p>Don’t forget to also include the new classes that we just wrote today. Thus, add the two include statements at the beginning of the <strong>main.cpp</strong> file.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&quot;RateMatrix_JC.h&quot;</span></span></code></pre></div>
<p>Also, make sure to update the <strong>Makefile</strong> to include all files:</p>
<pre><code>SRC       = Alignment.cpp AlignmentReader.cpp TreeNode.cpp Tree.cpp NewickTreeReader.cpp RandomNumberGenerator.cpp PureBirthProcess.cpp RateMatrix_JC.cpp main.cpp
OBJECTS   = Alignment.o AlignmentReader.o TreeNode.o Tree.o NewickTreeReader.o RandomNumberGenerator.o PureBirthProcess.o RateMatrix_JC.o main.o</code></pre>
<p>Now compile and run your <em>BabyBayes</em>. What are the transition probabilities for the different branch lengths?</p>
<h2 id="section-5.5-simulating-dna-sequences">Section 5.5: Simulating DNA Sequences</h2>
<p>In the previous section, we covered some of the most basic assumptions made in a phylogenetic analysis; DNA sequences are assumed to evolve on a phylogenetic tree (with branch lengths) under a continuous-time Markov model of DNA substitution. The substitution process is assumed to be independent across sites. These assumptions apply to maximum likelihood, Bayesian inference, and distance methods (when the distances are ‘corrected’ under some evolutionary model).</p>
<p>In this section, we will test our knowledge obtained in the previous section by simulating DNA sequences on a phylogenetic tree. Simulation is often used in phylogenetics. Simulation has been used to elucidate the statistical properties of different phylogenetic methods, and it can be used to generate the null distribution of a test statistic in phylogenetic hypothesis testing. In other words, learning to simulate DNA sequences is not a wasted effort. Not only can you strengthen your intuition of phylogenetic methods, but you may also be able to apply simulation for your own research.</p>
<p>How exactly should one simulate evolution on a phylogeneitc tree? One basic point is that an alignment should be simulated on a site-by-site basis. That is, we first simulate the data at the first site, then the second site, and so on. We can take this approach because of the assumption of independence of the substitution process across sites; to simulate the data at a particular site (column in the alignment), we don’t need to know the results of the simulation at any other site.</p>
<p>Another basic point is that we must know all of the parameters of the simulation: we have to decide on the precise phylogenetic tree on which to simulate the DNA sequences; we need to know the branch lengths on this tree; and, finally, we must pick a substitution model. The substitution model is a matrix of rates, specifying the rate of change from one nucleotide to another. In other words, we are taking a God-like view of the situation. We know <em>everything</em> about the evolutionary history and process. Of course, in reality we never know everything about how organisms evolved, but must make strong assumptions about how evolution occurred in order to estimate (make educated guesses) at the underlying evolutionary history. However, pretending to be a God, even for a little while, is a great feeling.</p>

<p>In the following, we will evolve DNA sequences on the four-taxon tree shown in Figure . We will also assume that DNA substitution occurs according to the JC69 model.</p>
<p>Now, we are ready to simulate data on the tree of Figure . We will go over two different methods for simulating data, each of which takes advantage of our knowledge of continuous-time Markov chains.</p>
<p>The first simulation method takes advantage of our knowledge of the stationary distribution and of our ability to calculate transition probabilities. There are only three different lengths of branches on our model tree (0.1, 0.2, and 0.3). The transition probabilities are <span class="math display">\[
\begin{array}{cc}
{\mathbf P}(0.10) = \left( \begin{array}{rrrr}
0.919 &amp; 0.018 &amp; 0.056 &amp; 0.006 \\
0.024 &amp; 0.934 &amp; 0.012 &amp; 0.029 \\
0.113 &amp; 0.018 &amp; 0.863 &amp; 0.006 \\
0.025 &amp; 0.086 &amp; 0.012 &amp; 0.877 \\
\end{array} \right)
 &amp;
{\mathbf P}(0.20) = \left( \begin{array}{rrrr}
0.851 &amp; 0.035 &amp; 0.100 &amp; 0.011  \\
0.047 &amp; 0.876 &amp; 0.023 &amp; 0.052  \\
0.201&amp;  0.035 &amp; 0.750 &amp; 0.011 \\
0.047 &amp; 0.156 &amp; 0.023 &amp; 0.771  \\
\end{array} \right)
\end{array}
\]</span> <span class="math display">\[
{\mathbf P}(0.30) = \left( \begin{array}{rrrr}
0.795 &amp; 0.051 &amp; 0.135 &amp; 0.017  \\
0.069 &amp; 0.824 &amp; 0.034 &amp; 0.071  \\
0.270 &amp; 0.051 &amp; 0.659 &amp; 0.017  \\
0.069 &amp; 0.214 &amp; 0.034 &amp; 0.681  \\
\end{array} \right)
\]</span> Instead of drawing exponential random variables, and generating the process continuously across the entire tree (see the exercise section), our simulation jumps from node to node on the tree. First, we generate the nucleotide at the root of the tree (the first split leading to all four taxa) by drawing from the stationary distribution. Then, we use the transition probabilities to simulate from one end to the other of each branch on the tree. We start from the root of the tree, and simulate up the tree to progressively higher branches until we have simulated a nucleotide at each tip of the tree.</p>
<h2 id="section-5.5.1-definition-of-the-phyloctmc-class">Section 5.5.1: Definition of the PhyloCTMC class</h2>
<p>Create a new file called <strong>PhyloCTMC.h</strong> and write the following class definition.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#ifndef PhyloCTMC_h</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="pp">#define PhyloCTMC_h</span></span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="pp">#include </span><span class="im">&quot;RandomNumberGenerator.h&quot;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="co">// forward declaration(s)</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">class</span> Alignment;</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">class</span> RateMatrix_JC;</span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="kw">class</span> Tree;</span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="kw">class</span> TreeNode;</span>
<span id="cb9-14"><a href="#cb9-14"></a></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="co">/**</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="co"> * </span><span class="an">\class</span><span class="co"> </span><span class="cv">PhyloCTMC</span></span>
<span id="cb9-17"><a href="#cb9-17"></a><span class="co"> *</span></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="co"> * </span><span class="an">\brief</span><span class="co"> A Continuous Time Markov chain (CTMC) process for simulating alignments and computing probabilities.</span></span>
<span id="cb9-19"><a href="#cb9-19"></a><span class="co"> *</span></span>
<span id="cb9-20"><a href="#cb9-20"></a><span class="co"> * This class represents a CTMC process along a phylogeny.</span></span>
<span id="cb9-21"><a href="#cb9-21"></a><span class="co"> * This class contains the main probability an likelihood computation function.</span></span>
<span id="cb9-22"><a href="#cb9-22"></a><span class="co"> *</span></span>
<span id="cb9-23"><a href="#cb9-23"></a><span class="co"> *</span></span>
<span id="cb9-24"><a href="#cb9-24"></a><span class="co"> * </span><span class="an">\author</span><span class="co"> Sebastian Höhna</span></span>
<span id="cb9-25"><a href="#cb9-25"></a><span class="co"> *</span></span>
<span id="cb9-26"><a href="#cb9-26"></a><span class="co">*/</span></span>
<span id="cb9-27"><a href="#cb9-27"></a><span class="kw">class</span> PhyloCTMC {</span>
<span id="cb9-28"><a href="#cb9-28"></a></span>
<span id="cb9-29"><a href="#cb9-29"></a><span class="kw">public</span>:</span>
<span id="cb9-30"><a href="#cb9-30"></a>    PhyloCTMC(<span class="at">const</span> Tree* phy, <span class="at">const</span> RateMatrix_JC* q);</span>
<span id="cb9-31"><a href="#cb9-31"></a>    <span class="kw">virtual</span>                    ~PhyloCTMC();</span>
<span id="cb9-32"><a href="#cb9-32"></a></span>
<span id="cb9-33"><a href="#cb9-33"></a>    <span class="dt">double</span>                      lnProbability(<span class="dt">void</span>) <span class="at">const</span> ;</span>
<span id="cb9-34"><a href="#cb9-34"></a>    Alignment*                  rv(RandomNumberGenerator *rng);</span>
<span id="cb9-35"><a href="#cb9-35"></a>    <span class="dt">void</span>                        setValue(<span class="at">const</span> Alignment *x);</span>
<span id="cb9-36"><a href="#cb9-36"></a></span>
<span id="cb9-37"><a href="#cb9-37"></a><span class="kw">private</span>:</span>
<span id="cb9-38"><a href="#cb9-38"></a>    <span class="dt">void</span>                        simulateAlignmentRecursively( <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; &gt;&amp; m,</span>
<span id="cb9-39"><a href="#cb9-39"></a>                                                              <span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt;&amp; ps,</span>
<span id="cb9-40"><a href="#cb9-40"></a>                                                              <span class="at">const</span> TreeNode* n,</span>
<span id="cb9-41"><a href="#cb9-41"></a>                                                              RandomNumberGenerator *rng );</span>
<span id="cb9-42"><a href="#cb9-42"></a></span>
<span id="cb9-43"><a href="#cb9-43"></a>    <span class="at">const</span> Tree*                 phylogeny;</span>
<span id="cb9-44"><a href="#cb9-44"></a>    <span class="at">const</span> RateMatrix_JC*        Q;</span>
<span id="cb9-45"><a href="#cb9-45"></a>    <span class="at">const</span> Alignment*            value;</span>
<span id="cb9-46"><a href="#cb9-46"></a></span>
<span id="cb9-47"><a href="#cb9-47"></a>};</span>
<span id="cb9-48"><a href="#cb9-48"></a></span>
<span id="cb9-49"><a href="#cb9-49"></a><span class="pp">#endif </span><span class="co">/* PhyloCTMC_h */</span></span></code></pre></div>
<p>This class defintion is similar to the definition of the <em>PureBirthProcess</em>.</p>
<h2 id="section-5.5.2-implementation-of-the-phyloctmc-class">Section 5.5.2: Implementation of the PhyloCTMC class</h2>
<p>Create a new file called <strong>PhyloCTMC.cpp</strong>.</p>
<p>First, add the include statements for all our header files for other classes that we need.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&quot;PhyloCTMC.h&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="pp">#include </span><span class="im">&quot;Alignment.h&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="pp">#include </span><span class="im">&quot;RateMatrix_JC.h&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="pp">#include </span><span class="im">&quot;Tree.h&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="pp">#include </span><span class="im">&quot;TreeNode.h&quot;</span></span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span></code></pre></div>
<p>Then, create the constructor which initialized our internal variables.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">/**</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co"> * Constructor of the PhyloCTMC.</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co"> *</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">phy</span><span class="co">         The phylogeny parameter.</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">q</span><span class="co">           The rate matrix parameter.</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co"> */</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>PhyloCTMC::PhyloCTMC(<span class="at">const</span> Tree* phy, <span class="at">const</span> RateMatrix_JC* q) :</span>
<span id="cb11-8"><a href="#cb11-8"></a>    phylogeny( phy ),</span>
<span id="cb11-9"><a href="#cb11-9"></a>    Q( q )</span>
<span id="cb11-10"><a href="#cb11-10"></a>{</span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>}</span></code></pre></div>
<p>The copy constructor which does not free any memory.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">/**</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="co"> * Destructor of the pure birth process.</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co"> */</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>PhyloCTMC::~PhyloCTMC( <span class="dt">void</span> )</span>
<span id="cb12-5"><a href="#cb12-5"></a>{</span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="co">// we do not own the rate parameter nor the value, so we have nothing to delete</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>}</span></code></pre></div>
<p>Here we also add a stub of the probability computation. However, we will actually add the content next week because it is slightly more involved.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">/**</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co"> * Compute the log-probability of the values given the CTMC process.</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co"> *</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co"> * More soon ...</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co"> *</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co"> * </span><span class="an">@return</span><span class="co">              Returns the log-probability.</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co"> */</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="dt">double</span> PhyloCTMC::lnProbability( <span class="dt">void</span> ) <span class="at">const</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>{</span>
<span id="cb13-10"><a href="#cb13-10"></a>    <span class="co">// initialize the log probability</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="dt">double</span> ln_prob = <span class="fl">0.0</span>;</span>
<span id="cb13-12"><a href="#cb13-12"></a></span>
<span id="cb13-13"><a href="#cb13-13"></a>    <span class="co">// we will add code here next week</span></span>
<span id="cb13-14"><a href="#cb13-14"></a></span>
<span id="cb13-15"><a href="#cb13-15"></a>    <span class="co">// return the computed log probability</span></span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="cf">return</span> ln_prob;</span>
<span id="cb13-17"><a href="#cb13-17"></a>}</span></code></pre></div>
<p>The important method for today is the simulation routine for sequence alignments.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">/**</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co"> * Draw a random alignment from a CTMC process along the phylogeny.</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co"> *</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">rng</span><span class="co">         The random number generator used for the simulation.</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="co"> * </span><span class="an">@return</span><span class="co">              The random alignment.</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="co"> */</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>Alignment* PhyloCTMC::rv(RandomNumberGenerator *rng)</span>
<span id="cb14-8"><a href="#cb14-8"></a>{</span>
<span id="cb14-9"><a href="#cb14-9"></a>    <span class="co">// we assume a rooted phylogeny with 2*n-1 nodes</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>    <span class="dt">size_t</span> num_taxa  = (phylogeny-&gt;getNumberOfNodes()+<span class="dv">1</span>) / <span class="dv">2</span>;</span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="dt">size_t</span> num_sites = <span class="dv">100</span>;</span>
<span id="cb14-12"><a href="#cb14-12"></a></span>
<span id="cb14-13"><a href="#cb14-13"></a>    <span class="co">// create an empty alignment</span></span>
<span id="cb14-14"><a href="#cb14-14"></a>    Alignment* a = <span class="kw">new</span> Alignment( num_taxa, num_sites );</span>
<span id="cb14-15"><a href="#cb14-15"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; &gt; data_matrix = <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; &gt;( num_taxa, <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt;(num_sites, <span class="ch">&#39;?&#39;</span>) );</span>
<span id="cb14-16"><a href="#cb14-16"></a></span>
<span id="cb14-17"><a href="#cb14-17"></a>    <span class="co">// now we want to start our simulation for the root node</span></span>
<span id="cb14-18"><a href="#cb14-18"></a>    <span class="co">// so we need to get the root node first</span></span>
<span id="cb14-19"><a href="#cb14-19"></a>    <span class="at">const</span> TreeNode* root = phylogeny-&gt;getRootNode();</span>
<span id="cb14-20"><a href="#cb14-20"></a>    <span class="co">// create and empty sequence</span></span>
<span id="cb14-21"><a href="#cb14-21"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; root_sequence = <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt;(num_sites, <span class="ch">&#39;?&#39;</span>);</span>
<span id="cb14-22"><a href="#cb14-22"></a>    <span class="co">// and then simulate each character from the prior</span></span>
<span id="cb14-23"><a href="#cb14-23"></a>    <span class="co">// the prior under the model are the stationary frequencies,</span></span>
<span id="cb14-24"><a href="#cb14-24"></a>    <span class="co">// which are all 1/4 for the Jukes-Cantor model</span></span>
<span id="cb14-25"><a href="#cb14-25"></a>    <span class="cf">for</span> ( <span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;num_sites; i++ )</span>
<span id="cb14-26"><a href="#cb14-26"></a>    {</span>
<span id="cb14-27"><a href="#cb14-27"></a>        <span class="dt">double</span> u = rng-&gt;uniform01();</span>
<span id="cb14-28"><a href="#cb14-28"></a>        <span class="cf">if</span> ( u &lt; <span class="fl">0.25</span> )</span>
<span id="cb14-29"><a href="#cb14-29"></a>        {</span>
<span id="cb14-30"><a href="#cb14-30"></a>            root_sequence[i] = <span class="ch">&#39;A&#39;</span>;</span>
<span id="cb14-31"><a href="#cb14-31"></a>        }</span>
<span id="cb14-32"><a href="#cb14-32"></a>        <span class="cf">else</span> <span class="cf">if</span> ( u &lt; <span class="fl">0.5</span> )</span>
<span id="cb14-33"><a href="#cb14-33"></a>        {</span>
<span id="cb14-34"><a href="#cb14-34"></a>            root_sequence[i] = <span class="ch">&#39;C&#39;</span>;</span>
<span id="cb14-35"><a href="#cb14-35"></a>        }</span>
<span id="cb14-36"><a href="#cb14-36"></a>        <span class="cf">else</span> <span class="cf">if</span> ( u &lt; <span class="fl">0.75</span> )</span>
<span id="cb14-37"><a href="#cb14-37"></a>        {</span>
<span id="cb14-38"><a href="#cb14-38"></a>            root_sequence[i] = <span class="ch">&#39;G&#39;</span>;</span>
<span id="cb14-39"><a href="#cb14-39"></a>        }</span>
<span id="cb14-40"><a href="#cb14-40"></a>        <span class="cf">else</span></span>
<span id="cb14-41"><a href="#cb14-41"></a>        {</span>
<span id="cb14-42"><a href="#cb14-42"></a>            root_sequence[i] = <span class="ch">&#39;T&#39;</span>;</span>
<span id="cb14-43"><a href="#cb14-43"></a>        }</span>
<span id="cb14-44"><a href="#cb14-44"></a>    }</span>
<span id="cb14-45"><a href="#cb14-45"></a></span>
<span id="cb14-46"><a href="#cb14-46"></a>    <span class="co">// simulate the sequence along the left and right branches of the root</span></span>
<span id="cb14-47"><a href="#cb14-47"></a>    simulateAlignmentRecursively( data_matrix, root_sequence, root-&gt;getLeftChild(), rng );</span>
<span id="cb14-48"><a href="#cb14-48"></a>    simulateAlignmentRecursively( data_matrix, root_sequence, root-&gt;getRightChild(), rng );</span>
<span id="cb14-49"><a href="#cb14-49"></a></span>
<span id="cb14-50"><a href="#cb14-50"></a>    <span class="co">// collect the taxon names</span></span>
<span id="cb14-51"><a href="#cb14-51"></a>    <span class="co">// we start with an empty vector</span></span>
<span id="cb14-52"><a href="#cb14-52"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; names = <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt;(num_taxa, <span class="st">&quot;&quot;</span>);</span>
<span id="cb14-53"><a href="#cb14-53"></a>    <span class="co">// then we get all nodes on ask for the names of the tips</span></span>
<span id="cb14-54"><a href="#cb14-54"></a>    <span class="at">const</span> <span class="bu">std::</span>vector&lt;TreeNode*&gt;&amp; nodes = phylogeny-&gt;getNodes();</span>
<span id="cb14-55"><a href="#cb14-55"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;num_taxa; i++)</span>
<span id="cb14-56"><a href="#cb14-56"></a>    {</span>
<span id="cb14-57"><a href="#cb14-57"></a>        names[i] = nodes[i]-&gt;getName();</span>
<span id="cb14-58"><a href="#cb14-58"></a>    }</span>
<span id="cb14-59"><a href="#cb14-59"></a></span>
<span id="cb14-60"><a href="#cb14-60"></a>    <span class="co">// fill the alignment with data</span></span>
<span id="cb14-61"><a href="#cb14-61"></a>    a-&gt;setTaxonNames( names );</span>
<span id="cb14-62"><a href="#cb14-62"></a>    a-&gt;setMatrix( data_matrix );</span>
<span id="cb14-63"><a href="#cb14-63"></a></span>
<span id="cb14-64"><a href="#cb14-64"></a></span>
<span id="cb14-65"><a href="#cb14-65"></a>    <span class="co">// and return the new alignment</span></span>
<span id="cb14-66"><a href="#cb14-66"></a>    <span class="cf">return</span> a;</span>
<span id="cb14-67"><a href="#cb14-67"></a>}</span></code></pre></div>
<p>The above method relies on our recursive simulation function.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">/**</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="co"> * Draw a random alignment from a CTMC process along the pylogeny.</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co"> *</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="co"> * </span><span class="an">@param</span><span class="co">   </span><span class="cv">rng</span><span class="co">         The random number generator used for the simulation.</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="co"> */</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="dt">void</span> PhyloCTMC::simulateAlignmentRecursively( <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; &gt;&amp; data, <span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt;&amp; parent_sequence, <span class="at">const</span> TreeNode* node, RandomNumberGenerator *rng )</span>
<span id="cb15-7"><a href="#cb15-7"></a>{</span>
<span id="cb15-8"><a href="#cb15-8"></a></span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="dt">size_t</span> num_sites = parent_sequence.size();</span>
<span id="cb15-10"><a href="#cb15-10"></a></span>
<span id="cb15-11"><a href="#cb15-11"></a>    <span class="co">// create and empty sequence</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt; sequence = <span class="bu">std::</span>vector&lt;<span class="dt">char</span>&gt;(num_sites, <span class="ch">&#39;?&#39;</span>);</span>
<span id="cb15-13"><a href="#cb15-13"></a></span>
<span id="cb15-14"><a href="#cb15-14"></a>    <span class="dt">double</span> time = node-&gt;getBranchLength();</span>
<span id="cb15-15"><a href="#cb15-15"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &gt; P = Q-&gt;calculateTransitionProbabilities(time, <span class="fl">1.0</span>);</span>
<span id="cb15-16"><a href="#cb15-16"></a></span>
<span id="cb15-17"><a href="#cb15-17"></a>    <span class="co">// and then simulate each character using the transition probabilities</span></span>
<span id="cb15-18"><a href="#cb15-18"></a>    <span class="cf">for</span> ( <span class="dt">size_t</span> i=<span class="dv">0</span>; i&lt;num_sites; i++ )</span>
<span id="cb15-19"><a href="#cb15-19"></a>    {</span>
<span id="cb15-20"><a href="#cb15-20"></a>        <span class="co">// first, we need to get the transition probabilities for this starting character</span></span>
<span id="cb15-21"><a href="#cb15-21"></a>        <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; this_transition_probability;</span>
<span id="cb15-22"><a href="#cb15-22"></a></span>
<span id="cb15-23"><a href="#cb15-23"></a>        <span class="cf">switch</span> (parent_sequence[i])</span>
<span id="cb15-24"><a href="#cb15-24"></a>        {</span>
<span id="cb15-25"><a href="#cb15-25"></a>            <span class="cf">case</span> <span class="ch">&#39;A&#39;</span>:</span>
<span id="cb15-26"><a href="#cb15-26"></a>                this_transition_probability = P[<span class="dv">0</span>];</span>
<span id="cb15-27"><a href="#cb15-27"></a>                <span class="cf">break</span>;</span>
<span id="cb15-28"><a href="#cb15-28"></a></span>
<span id="cb15-29"><a href="#cb15-29"></a>            <span class="cf">case</span> <span class="ch">&#39;C&#39;</span>:</span>
<span id="cb15-30"><a href="#cb15-30"></a>                this_transition_probability = P[<span class="dv">1</span>];</span>
<span id="cb15-31"><a href="#cb15-31"></a>                <span class="cf">break</span>;</span>
<span id="cb15-32"><a href="#cb15-32"></a></span>
<span id="cb15-33"><a href="#cb15-33"></a>            <span class="cf">case</span> <span class="ch">&#39;G&#39;</span>:</span>
<span id="cb15-34"><a href="#cb15-34"></a>                this_transition_probability = P[<span class="dv">2</span>];</span>
<span id="cb15-35"><a href="#cb15-35"></a>                <span class="cf">break</span>;</span>
<span id="cb15-36"><a href="#cb15-36"></a></span>
<span id="cb15-37"><a href="#cb15-37"></a>            <span class="cf">case</span> <span class="ch">&#39;T&#39;</span>:</span>
<span id="cb15-38"><a href="#cb15-38"></a>                this_transition_probability = P[<span class="dv">3</span>];</span>
<span id="cb15-39"><a href="#cb15-39"></a>                <span class="cf">break</span>;</span>
<span id="cb15-40"><a href="#cb15-40"></a></span>
<span id="cb15-41"><a href="#cb15-41"></a>            <span class="cf">default</span>:</span>
<span id="cb15-42"><a href="#cb15-42"></a>                <span class="cf">break</span>;</span>
<span id="cb15-43"><a href="#cb15-43"></a>        }</span>
<span id="cb15-44"><a href="#cb15-44"></a></span>
<span id="cb15-45"><a href="#cb15-45"></a>        <span class="co">// simulate the</span></span>
<span id="cb15-46"><a href="#cb15-46"></a>        <span class="dt">double</span> u = rng-&gt;uniform01();</span>
<span id="cb15-47"><a href="#cb15-47"></a>        <span class="cf">if</span> ( u &lt; this_transition_probability[<span class="dv">0</span>] )</span>
<span id="cb15-48"><a href="#cb15-48"></a>        {</span>
<span id="cb15-49"><a href="#cb15-49"></a>            sequence[i] = <span class="ch">&#39;A&#39;</span>;</span>
<span id="cb15-50"><a href="#cb15-50"></a>        }</span>
<span id="cb15-51"><a href="#cb15-51"></a>        <span class="cf">else</span> <span class="cf">if</span> ( u &lt; (this_transition_probability[<span class="dv">0</span>]+this_transition_probability[<span class="dv">1</span>]) )</span>
<span id="cb15-52"><a href="#cb15-52"></a>        {</span>
<span id="cb15-53"><a href="#cb15-53"></a>            sequence[i] = <span class="ch">&#39;C&#39;</span>;</span>
<span id="cb15-54"><a href="#cb15-54"></a>        }</span>
<span id="cb15-55"><a href="#cb15-55"></a>        <span class="cf">else</span> <span class="cf">if</span> ( u &lt; (this_transition_probability[<span class="dv">0</span>]+this_transition_probability[<span class="dv">1</span>]+this_transition_probability[<span class="dv">2</span>]) )</span>
<span id="cb15-56"><a href="#cb15-56"></a>        {</span>
<span id="cb15-57"><a href="#cb15-57"></a>            sequence[i] = <span class="ch">&#39;G&#39;</span>;</span>
<span id="cb15-58"><a href="#cb15-58"></a>        }</span>
<span id="cb15-59"><a href="#cb15-59"></a>        <span class="cf">else</span></span>
<span id="cb15-60"><a href="#cb15-60"></a>        {</span>
<span id="cb15-61"><a href="#cb15-61"></a>            sequence[i] = <span class="ch">&#39;T&#39;</span>;</span>
<span id="cb15-62"><a href="#cb15-62"></a>        }</span>
<span id="cb15-63"><a href="#cb15-63"></a>    }</span>
<span id="cb15-64"><a href="#cb15-64"></a></span>
<span id="cb15-65"><a href="#cb15-65"></a>    <span class="co">// finally, we need to set the sequence into the data matrix (if this node is a tip node)</span></span>
<span id="cb15-66"><a href="#cb15-66"></a>    <span class="co">// or continue with the recursive simulation if this is an interior node</span></span>
<span id="cb15-67"><a href="#cb15-67"></a>    <span class="cf">if</span> ( node-&gt;isTip() )</span>
<span id="cb15-68"><a href="#cb15-68"></a>    {</span>
<span id="cb15-69"><a href="#cb15-69"></a>        data[ node-&gt;getIndex() ] = sequence;</span>
<span id="cb15-70"><a href="#cb15-70"></a>    }</span>
<span id="cb15-71"><a href="#cb15-71"></a>    <span class="cf">else</span></span>
<span id="cb15-72"><a href="#cb15-72"></a>    {</span>
<span id="cb15-73"><a href="#cb15-73"></a>        simulateAlignmentRecursively( data, sequence, node-&gt;getLeftChild(), rng );</span>
<span id="cb15-74"><a href="#cb15-74"></a>        simulateAlignmentRecursively( data, sequence, node-&gt;getRightChild(), rng );</span>
<span id="cb15-75"><a href="#cb15-75"></a>    }</span>
<span id="cb15-76"><a href="#cb15-76"></a></span>
<span id="cb15-77"><a href="#cb15-77"></a></span>
<span id="cb15-78"><a href="#cb15-78"></a>}</span></code></pre></div>
<h3 id="subsection-5.5.3-testing-your-alignment-simulator">Subsection 5.5.3: Testing your Alignment Simulator</h3>
<p>In your <strong>main.cpp</strong> file, add the following lines:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a>RandomNumberGenerator *rng = <span class="kw">new</span> RandomNumberGenerator();</span>
<span id="cb16-2"><a href="#cb16-2"></a></span>
<span id="cb16-3"><a href="#cb16-3"></a>PhyloCTMC ctmc = PhyloCTMC( &amp;trees[<span class="dv">0</span>], my_rate_matrix );</span>
<span id="cb16-4"><a href="#cb16-4"></a>Alignment *sim_align = ctmc.rv(rng);</span>
<span id="cb16-5"><a href="#cb16-5"></a>sim_align-&gt;print(<span class="bu">std::</span>cout);</span></code></pre></div>
<p>Don’t forget to also include the new classes that we just wrote today. Thus, add the two include statements at the beginning of the <strong>main.cpp</strong> file.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&quot;PhyloCTMC.h&quot;</span></span></code></pre></div>
<p>Also, make sure to update the <strong>Makefile</strong> to include all files:</p>
<pre><code>SRC       = Alignment.cpp AlignmentReader.cpp TreeNode.cpp Tree.cpp NewickTreeReader.cpp RandomNumberGenerator.cpp PureBirthProcess.cpp RateMatrix_JC.cpp PhyloCTMC.cpp main.cpp
OBJECTS   = Alignment.o AlignmentReader.o TreeNode.o Tree.o NewickTreeReader.o RandomNumberGenerator.o PureBirthProcess.o RateMatrix_JC.o PhyloCTMC.o main.o</code></pre>
<p>Now compile and run your <em>BabyBayes</em>. How does your simulated alignment look? How many times did you observe the patter ‘AAAA’, ‘CCCC’, ‘GGGG’, ‘TTTT’? Compare with your neighbor. How many times did you observe the patter ‘AACC’, ‘CCTT’, ‘GGTT’? Perhaps you want to write some code to check this, and the frequency of all <span class="math inline">\(4^4\)</span> possible patterns.</p>
<h2 id="section-5.6-exercises">Section 5.6: Exercises</h2>
<h3 id="subsection-5.6.1-the-felsenstein-1981-model">Subsection 5.6.1: The Felsenstein 1981 Model</h3>
<p>In our example, we used the very simple Jukes-Cantor substitution model. In your first exercise, implement the Felsenstein 1981 substitution model. This F81 model has unequal stationary frequencies. The resulting Q matric looks like. <span class="math display">\[
{\mathbf Q} = \{q_{ij}\} = \left( \begin{array}{cccc}
1 - \pi_A &amp;  \pi_C &amp;  \pi_G &amp;  \pi_T \\
\pi_A &amp;  1 - \pi_C &amp;  \pi_G &amp;  \pi_T \\
\pi_A &amp;  \pi_C &amp;  1 - \pi_G &amp;  \pi_T \\
\pi_A &amp;  \pi_C &amp;  \pi_G &amp;  1 - \pi_T \\
\end{array} \right)
\]</span> You can compute the transition probabilities using the following equations: <span class="math display">\[
\beta = 1/(1-\pi_A^2-\pi_C^2-\pi_G^2-\pi_T^2)
\]</span> and <span class="math display">\[
{\mathbf P}_{ij}(\nu) = \begin{cases}
e^{-\beta\nu}+\pi_j\left(1- e^{-\beta\nu}\right) &amp; \mbox{ if } i = j   \\
\pi_j\left(1- e^{-\beta\nu}\right) &amp; \mbox{ if } i \neq j  
\end{cases}
\]</span> Implement this rate matrix and compute transition probabilities for a range of branch lengths.</p>
<h3 id="subsection-5.6.2-the-hasegawa-kishino-yano-model">Subsection 5.6.2: The Hasegawa-Kishino-Yano Model</h3>
<p>Similar to the JC69 and F81 models, we can develop the HKY85 substitution process. The rate matrix is <span class="math display">\[
{\mathbf Q} = \{q_{ij}\} = \left( \begin{array}{cccc}
{*} &amp;  \pi_C &amp;  \kappa\pi_G &amp;  \pi_T \\
\pi_A &amp;  {*} &amp;  \pi_G &amp;  \kappa\pi_T \\
\kappa\pi_A &amp;  \pi_C &amp;  {*} &amp;  \pi_T \\
\pi_A &amp;  \kappa\pi_C &amp;  \pi_G &amp;  {*} \\
\end{array} \right)
\]</span></p>
<p>If we express the branch length, ’‘ν’’ in terms of the expected number of changes per site then: <span class="math display">\[
\begin{eqnarray}
\beta  = &amp; \frac{1}{2(\pi_A + \pi_G)(\pi_C + \pi_T) + 2\kappa[(\pi_A\pi_G) + (\pi_C\pi_T)]} \\
P_{AA}(\nu,\kappa,\pi)  =  &amp; \left[\pi_A\left(\pi_A + \pi_G + (\pi_C + \pi_T)e^{-\beta\nu}\right) + \pi_G e^{-(1 + (\pi_A + \pi_G)(\kappa - 1.0))\beta\nu}\right]/(\pi_A + \pi_G)\\
P_{AC}(\nu,\kappa,\pi)  = &amp; \pi_C\left(1.0 - e^{-\beta\nu}\right)\\
P_{AG}(\nu,\kappa,\pi)  = &amp; \left[\pi_G\left(\pi_A + \pi_G + (\pi_C + \pi_T)e^{-\beta\nu}\right) - \pi_Ge^{-(1 + (\pi_A + \pi_G)(\kappa - 1.0))\beta\nu}\right] /\left(\pi_A + \pi_G\right) \\
P_{AT}(\nu,\kappa,\pi)  =  &amp; \pi_T\left(1.0 - e^{-\beta\nu}\right)
\end{eqnarray}
\]</span></p>
<h2 id="subsection-5.6.3-using-substitution-rates-to-simulate-alignments">Subsection 5.6.3: Using Substitution Rates to Simulate Alignments</h2>
<p>The second method only relies on our ability to generate exponentially distributed random numbers. If we generate a uniform random number on the interval (0,1), we can generate an exponential random number (with parameters <span class="math inline">\(\lambda\)</span>) using the transformation <span class="math inline">\(t = -{1 \over \lambda} \log_e(u)\)</span> (where <span class="math inline">\(u\)</span> is the uniform random number and <span class="math inline">\(t\)</span> is the exponentially distributed random number). This second method involves an addition to the tree of Figure~ which seems unusual: We take the tree of Figure~, and add a ‘tail’ to it —a branch that extends for some distance from the root of the tree. In this case, the branch at the root of the tree is <span class="math inline">\(v_0 = 10.0\)</span> in length. Moreover, we assume that the process is in state (nucleotide) A at the very root of the tree. The situation we have is like that shown in Figure~.</p>
<p>We simulate the process starting at the root of the tree. The process is in state A, meaning that the only relevant row of the rate matrix is the first one: <span class="math display">\[
{\mathbf Q} = \{q_{ij}\} = \left( \begin{array}{cccc}
-0.886 &amp;  0.190 &amp;  0.633 &amp;  0.063 \\
\cdot &amp; \cdot &amp;  \cdot &amp;  \cdot \\
\cdot &amp;  \cdot &amp; \cdot &amp;  \cdot \\
\cdot &amp;  \cdot &amp;  \cdot &amp; \cdot \\
\end{array} \right)
\]</span> We wait an exponentially distributed amount of time with parameter <span class="math inline">\(\lambda = 0.886\)</span> until the next substitution occurs. When the substitution occurs, it is to a <span class="math inline">\(C\)</span>, <span class="math inline">\(G\)</span>, or <span class="math inline">\(T\)</span> with probabilities <span class="math inline">\({0.190 \over 0.886} = 0.214\)</span>, <span class="math inline">\({0.633 \over 0.886} = 0.714\)</span>, and <span class="math inline">\({0.063 \over 0.886} = 0.072\)</span>, respectively. In the first section, we used this method for simulating along a single branch of a tree. Here we apply the method with vigor, applying it to each branch in the tree from the root to the tips. We continue to simulate up the root branch of the tree until our simulation exceeds the length of the branch. We then record the nucleotide state the process was in when it exceeded a length of 10. We write this state at the end of the root branch, where it splits into branches 1 and 6. We then repeat the simulation process for branch 1 and then branch 6, recording the state the process is in at the end of those two branches. We then concentrate our attention on branches 4 and 5, and then on branches 2 and 3. At the end, we should have nucleotides at the ends of branches 1, 2, 3, and 4.</p>

<p>One puzzling aspect of this simulation is why we always start the process in nucleotide A, and why we even bothered to add the tail to the root of the tree. We did this because for this method, we assume ignorance of the stationary distribution of the rate matrix. If this is the case, we can use our understanding of the rate matrix as specifying waiting times between substitutions to complete our simulation.<br />
Hence, we always start our simulations in a particular nucleotide (in this case we chose to start in the nucleotide A), and then simulate the process for a long time along the root (tail) branch of the tree. The hope is that if we make the length of the tail branch long enough, that the process is at stationarity by the time it reaches the first split in the tree (the speciation event that eventually produces the four species at the tips of the tree).</p>
<p>This method relies on the idea that we can come pretty near to stationarity with a moderately long branch. We know that the stationary distribution of the HKY85 process of nucleotide substitution with the specific parameters we chose is <span class="math inline">\(\pi_A = 0.4\)</span>, <span class="math inline">\(\pi_C = 0.3\)</span>, <span class="math inline">\(\pi_G = 0.2\)</span>, <span class="math inline">\(\pi_T = 0.1\)</span>. We also know that the transition probability for a branch of <span class="math inline">\(v = 10.0\)</span> is <span class="math display">\[
{\mathbf P}(10.0) = \left( \begin{array}{rrrr}
0.401 &amp; 0.299 &amp; 0.200 &amp; 0.099 \\
0.399 &amp; 0.301 &amp; 0.199 &amp; 0.100 \\
0.401 &amp; 0.299 &amp; 0.200 &amp; 0.099 \\
0.399 &amp; 0.301 &amp; 0.199 &amp; 0.100 \\
\end{array} \right)
\]</span> The transition probability matrix tells us that if we start in nucleotide A, then we end up in state A, C, G, and T with probabilities 0.401, 0.299, 0.200, and 0.099, respectively. These numbers are very close to the actual stationary probabilities, so perhaps this method is not such a bad one.</p>
<div>
<h2 id="references">References</h2>
</div>

<div id="refs" class="references" role="doc-bibliography">
<div id="ref-hasegawa85">
<p>Hasegawa, M., H. Kishino, and T. Yano. 1985. Dating the human-ape splitting by a molecular clock of mitochondrial DNA. Journal of Molecular Evolution 22:160–174.</p>
</div>
</div>
</body>
</html>
